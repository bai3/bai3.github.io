<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《JSON必知必会》读书笔记]]></title>
    <url>%2F2017%2F05%2F25%2Fjson%2F</url>
    <content type="text"><![CDATA[将之前写在onenote的关于json的简要知识点改写成md。 第一章 什么是JSON JSON指的是JavaScript对象表示法（JavaScript Object Notation） JSON是轻量级的文本数据交换格式 JSON独立于语言 JSON具有自我描述性，更易理解 JSON使用JavaScript语法来描述数据对象，但是JSON独立于语言和平台。JSON解析器和JSON库之处许多不同的编程语言。目前非常多的动态（PHP、JSP、.NET）编程语言都支持JSON。 第二章 JSON的语法JSON中的名称—值对的名称如果被系统作为对象装入内存的话，将会成为”属性“，不同于名称，值并不是总是需要被双引号包裹。当值是字符串时，必须使用双引号。而在JSON中，数字、布尔值、数组、对象、null等其他类型，这些都不应该被双引号包裹。 例如： 12345678910111213&#123; title："this is my title"&#125;//不合法&#123; 'title':'this is my title'&#125;//同样不合法&#123; "title":"this is my title"&#125;//合法的书写&#123; "value":12 "result":true&#125;//这些都不加双引号 JSON的名称始终被双引号包裹 JSON文件使用.json扩展名 第三章 JSON的数据结构JSON的数据类型： 对象 字符串 数字 布尔值 null 数组 基本嵌套格式 1234567891011121314&#123; "person":&#123; "name":"Lindasy Bassett", "heightInInches":66, "head":&#123; "hair":&#123; "color":"light blood", "length":"short", "style":"A-line" &#125;, "eyes":"green" &#125; &#125;&#125; 注意事项： 遇到双引号、反斜线、\/（正斜线）、\b、\f、\t、\n、\r都需要进行转义（加\） 在JSON中布尔值仅能用true和false表示，任何其他形式的写法都会报错（所有字母必须要小写）。 对象和数组很关键的一个区别就是，对象是名称-值对构成的列表或者集合，数组是值构成的列表或者集合。 对象和数组另一个关键的区别是，数组中所有的值应具有相同的的数据类型。 第四章 JSON Schema基础概念 jsonschema是描述你的JSON数据格式；JSON模式（应用程序/模式+ JSON）有多种用途，其中之一就是实例验证。验证过程可以是交互式或非交互式的。例如，应用程序可以使用JSON模式来构建用户界面使互动的内容生成除了用户输入检查或验证各种来源获取的数据。 基本格式 12345678910111213141516&#123; "schema":"http://json-schame.org/draft-04/shema", "title":"Cat",//文件标题 "properties":&#123; "name":&#123; "type":"string" &#125;, "age":&#123; "tyep":"number", "description":"Your cat's age in year" &#125;, "declawd":&#123; "type":"boolean" &#125; &#125;&#125; “required”，值为一个数组，数组中含必填的字段。如果你的JSON Schema中不含”required“名称–值对，那么将不必有必填项。 总结： JSON Schema是数据交换中的一种虚拟的”合同“ JSON验证器负责验证语法错误，JSON Schema负责提供一致性检验 JSON Schema可以解决下列有关一致性检验的问题。 ——值的数据类型是否正确？ ​ 可以具体规定一个值是数字、字符串等类型 ——是否包含所需要的数据 可以具体规定哪些数据是需要的，哪些是不需要的 ——值的形式是否是我需要的？ 可以指定范围、最小值、最大值。 第六章 JavaScript中的XMLHTTPRequest与Web API基本格式 12345678910var xml=new XMLHTTPRequest();var url="#";xml.onreadystatechange=function()&#123; if(xml.readyState===4 &amp;&amp; xml.state===200)&#123; var myObject = JSON.parse(xml.responseText); var myJSON = JSON.stringify(myObject); &#125;&#125;xml.open("GET",url,true);xml.send(); JSON.parse:反序列化操作，JSON解析成JavaScript对象 JSON.stringify:序列化操作，将JavaScript对象解析成JSON JavaScript中的XMLHttpRequest负责在客户端发起请求，而web API负责在服务端返回响应 XMLHTTPRequest主要属性含义 onreadystatechange 可以在代码中给它赋值为一个函数 readyState 返回一个0~4的值，用来表示状态码 status 返回Http状态码（如200请求表示成功） responseText 当请求成功时，该属性会包含作为文本的响应体 ​]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS高程复习]]></title>
    <url>%2F2017%2F05%2F25%2FJS%E9%AB%98%E7%A8%8B%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[&ensp; 之前在学JS基础的时候已经刷过一次，只不过上次很多东西没错，最近忙于暑期实习，所以特意又将这本书再刷一遍，在仔细作一遍笔记，把之前遗落的知识点重新学习一下。主要记一点面试的知识点。 17/5/25 第一章 JavaScript简介JavaScript实现一个完整的JavaScript实现包括三个不同的部分组成 核心(ECMAScript) 文档对象模型(DOM) 浏览器对象（BOM） ECMAScript即是JS的标准，目前已经到ES6。 DOM简单理解就是HTML内容 #第二章 在HTML中使用JavaScript &lt;\script&gt;元素标签的位置 html文件是自上而下的执行方式，但引入的css和javascript的顺序有所不同，css引入执行加载时，程序仍然往下执行，而执行到&lt;\script&gt;脚本是则中断线程，待该script脚本执行结束之后程序才继续往下执行。所以，一般将script放在body之后是因为避免长时间执行script脚本而延迟阻塞。而有一些页面的效果的实现，是需要预先动态的加载一些js脚本，所以这些脚本应该放在&lt;\body&gt;之前。其次，不能将需要访问dom元素的js放在body之前，因为此时还没有开始生成dom，所以在body之前的访问dom元素的js会出错，或者无效。就是因为这个，在dom没生成好时我就给它添加了方法，才导致这样 延迟脚本defer只能适用外部脚本文件 defer属性的用于是表明脚本在执行的时候不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后在运行。因此在&lt;\script&gt;元素中设置defer属性，想当于告诉浏览器立即下载，但延迟执行。 异步脚本HTML5为&lt;\script&gt;开始设置一个async属性，这个属性与defer属性相似，都用于改变处理脚本的行为。同样只是适用脚本文件。 defer与async的差异 123&lt;script src="myscript.js"&gt;&lt;/script&gt;&lt;script async src="myscript.js"&gt;&lt;/script&gt;&lt;script defer src="myscript.js"&gt;&lt;/script&gt; 下面是stackoverflow上的回答，可以参考一下： Without async or defer, browser will run your script immediately, before rendering the elements that’s below your script tag. With async (asynchronous), browser will continue to load the HTML page and render it while the browser load and execute the script at the same time. With defer, browser will run your script when the page finished parsing. (not necessary finishing downloading all image files. This is good.) 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。 高程中解释： 使用defer属性可以让脚本在文档中完全呈现之后再执行，延迟脚本总是按照指定他们的顺序执行。 使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照他们在页面中出现的顺序。 第三章 基本概念语法### ECMAScript是明确区分大小写的 变量 虽然省略var操作符可以定义全局变量，但这也不是我们推荐的做法。因为在局部作用域中定义的全局变量很难维护，而且如果有意地省略var操作符，也会由于相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式下回导致抛出ReferenceError错误。 数据类型ES有5种基本数据类型:Undefined、Null、Boolean、Number和String，还有一种复杂数据类型Object。 对未初始化的变量执行typeof操作符会返回undefined值，而对未声明的变量执行typeof操作符同样也会返回undefined值。 操作符加性操作符如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来。 如果只有一个操作数是字符串，则将另一个操作数转换成字符串，然后再将两个字符串拼接起来。 相等操作符W3的说明： Operator Description == equal to === equal value andequal type ！= not equal ！== not equal value or not equal type]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript高程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解HTTP]]></title>
    <url>%2F2017%2F05%2F24%2FREADME%2F</url>
    <content type="text"><![CDATA[图解HTTP 点这里 第一章 第二章 第三章 第四章 第五章 第六章 第七章 第八章 第九章]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2017%2F05%2F24%2FAjax%2F</url>
    <content type="text"><![CDATA[Ajax教程 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 Ajax应用 运用XHTML+CSS来表达资讯； 运用JavaScript操作DOM（Document Object Model）来执行动态效果； 运用XML和XSLT操作资料; 运用XMLHttpRequest或新的Fetch API与网页服务器进行异步资料交换； 注意：AJAX与Flash、Silverlight和Java Applet等RIA技术是有区分的。 Ajax工作原理图列: Ajax创建对象 XMLHttpRequest是Ajax的基础 XMLHTTPRequest 对象XMLHTTPRequest用于在后台与服务器交换数据。这意味着可以再不重新加载整个网页情况下，对网页的某部分进行更新。 创建XMLHTTPRequest1variable = new XMLHTTPRequest(); 老版本的IE浏览器使用ActiveX对象 1variable = new ActiveXObject("Microsoft.XMLHTTP"); 为了应对所有浏览器，故采用下列写法 1234567891011var xmlhttp;if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest();&#125;else&#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");&#125; Ajax 向服务器发送请求 XMLHttPRequest对象用于和服务器交换数据 向服务器发送请求如需将强求发送服务器，我们使用XMLHttpRequest对象的open()和send()方法 12xmlhttp.open("GET","ajax_info.txt",true);xmlhttp.send(); 方法 描述 open（method,url,async) 规定请求的类型、URL以及是否异步处理请求 send(string) 将请求发送到服务器 !仅用于POST请求 GET和POST的区别与POST相比，GET更简单也更快 然而，在以下情况中，请使用POST请求 无法使用缓存文件（更新服务器的文件或数据） 向服务器发送大量数据（POST没有数据量限制） 发送包含未知字符的用户输入时，POST比GET更稳定也更可靠 GET请求一个简单的GET请求 12xmlhttp.open("GET","/try/ajax/demo_get.php",true);xmlhttp.send(); 可是上面的例子你可能得到的是缓存的结果，为了避免这种情况，向URL添加一个唯一的ID 例如： 12xmlhttp.open("GET","/try/ajax/demo_get.php?t="+Math.random(),true);xmlhttp.send(); Math.random()是数学随机数的意思 POST请求例子 12xmlhttp.open("POST","/try/ajax/demo_post.php",true);xmlhttp.send(); POST也可以像HTML表单那样POST数据，请使用setRequestHeader()来添加HTTP头。然后在send()方法中规定你希望发送的数据 实例： 123xmlhttp.open("POST","/try/ajax/demo_post2.php",true);xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");xmlhttp.send("fname=Henry&amp;lname=Ford"); way description setRequestHeader(header,value) 向请求添加HTTP头。- header：规定头的名称- value：规定头的值 url-服务器上的文件open()方法的url参数是服务器上文件的地址 1xmlhttp.open("GET","ajax_test.html",true); 异步 True或False？通过AJAX，JavaScript无需等待服务器的响应，而是： 在等待服务器响应时执行其他的脚本 当响应就绪后响应进行处理###Async=true 当使用async=true的时候，规定在响应处于onreadystatechange事件中的就绪状态时执行的函数 ###Async=false如果需要async=false，请将open()方法中的第三个参数改为false。 我们不推荐使用async=false，但对于一些小型的请求也是可以的。 请记住，JavaScript会等到服务器响应就绪才继续执行。如果服务器繁忙或者缓慢，应用程序会挂机或停止 Ajax-服务器 响应服务器响应如需获得来自服务器的响应，请使用XMLHttpRequest对象的responseText或responseXML属性。 属性 描述 responseText 获得字符串形式的响应数据 responseXML 获得XML形式的响应数据 responseText的实例响应不是XML 1document.getElementById("myDiv").innerHTML=xmlhttp.resposeText; 响应是XML，则采用respondText属性，实例 12345678xmlDoc=xmlhttp.responseXML;txt="";x=xmlDoc.getElementsByTagName("ARTIST");for (i=0;i&lt;x.length;i++)&#123; txt=txt + x[i].childNodes[0].nodeValue + "&lt;br&gt;";&#125;document.getElementById("myDiv").innerHTML=txt; Ajax - onreadystatechange事件当请求被发送到服务器时，我们需要执行一些基于响应的任务 每单readyState改变时，就会触发onreadystatechange事件. readyState 属性存在XMLHttpRequest的状态信息。 下面是XMLHttpRequest 对象的三个重要属性 属性 描述 onreadystatechange 存储函数（或函数名），每readyState属性改变时，就会调用该函数 readyState 存在XMLHttpRequest的状态，从0到4发生变化。0：请求未初始化1：服务器连接已建立 2：请求已接受 3：请求处理中 4：请求已完成，且响应已就绪 status 200：“OK” 404：没有找到页面 在onreadystatechange时间中，我们规定当服务器响应已做好被处理的准备时所执行的任务 当readyState等于4且状态为200时，表示响应已就绪。 具体例子 123456xmlhttp.onreadystatechange=function()&#123; if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200) &#123; document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125;&#125; 使用回调函数如果你的网站上有多个AJAX任务，那么你应该创建XMLHTTPRequest对象编写出一个标准的函数，并为每个AJAX任务调用该函数。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[resume]]></title>
    <url>%2F2017%2F05%2F24%2Fresume%2F</url>
    <content type="text"><![CDATA[简历的照片贴在md中。如果要看html文件或者pdf源文件​点击这，我的github]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>resume</tag>
        <tag>about</tag>
      </tags>
  </entry>
</search>