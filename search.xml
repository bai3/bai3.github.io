<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript阻止气泡]]></title>
    <url>%2F2017%2F09%2F08%2FJavaScript%E9%98%BB%E6%AD%A2%E6%B0%94%E6%B3%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript!==和!=]]></title>
    <url>%2F2017%2F09%2F06%2FJavaScript!%3D%E5%92%8C!%3D%3D%2F</url>
    <content type="text"><![CDATA[!== 与 != 的区别这次笔记主要是理清JavaScript中的 != 和 !==的区别在JavaScript中“===”叫做严格运算符，而“==”叫做相等运算符。 严格运算符的运算规格如下(抄录知乎某兄弟) 不同类型值 如果两个值得类型不同，直接返回false。 同一类的原始类型值 同一类型的原始类型的值(数值、字符串、布尔值)比较值，如果值相同就返回true，值不同就返回false。 同一类的复合类型值(重点) 两个复合类型(对象、数组、函数)的数据比较时，不是比较他们的植是否相等，而是比较它们是否指向同一对象。 undefined和null nuderfined 和 null与自身严格相等 1234null === null //=&gt;trueundefined === undefined // =&gt;truenull === undefined // =&gt;false null == undefined //=&gt;true 相等运算符在比较相同类型的数据时，与严格相等运算符一样。 在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符进行比较 原始类型的值 原始类型的数据会转换数值类型再进行比较。字符串和布尔值都会转换成数值 对高级的类型，比如函数，对象，数组，===与==没有区别。 最后总结，最好用严格运算符。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[载流函数的使用]]></title>
    <url>%2F2017%2F08%2F21%2F%E8%BD%BD%E6%B5%81%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[JavaScript节流函数(载流函数)Throttle解析自己项目中一般载流函数的写法。 1234567//截流函数 self.throttle = function (method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function () &#123; method.call(context); &#125;, 400); &#125;; 载流函数的作用在浏览器DOM事件中，有一些事件会随着用户的操作不间断的触发。 有时候如果事件处理方法比较庞大，DOM操作比较复杂，还不断的促发此类事件就会造成性能上的损失，导致用户体验较低(UI反应慢，浏览器卡死)，所以通常我们会给相应事件添加延迟执行的逻辑。 网上copy的代码1234567var timer = null;window.onresize = function () &#123; clearTimeout(timer); timer = setTimeout(function() &#123; testFn(); &#125;, 100);&#125;; 感觉跟我项目用的差不多(我的书写主要是照着前一位学长写的) 产生的问题如果js代码中还有别的功能也叫timer就产生冲突，可以采用闭包来解决 123456789101112131415var throttle = function (fn, delay) &#123; var timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(function() &#123; fn(); &#125;, delay); &#125;&#125;;var f = throttle(testFn, 200);window.onresize = function () &#123; f();&#125;;]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度2017春招笔试编程题]]></title>
    <url>%2F2017%2F06%2F25%2F%E7%99%BE%E5%BA%A62017%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一题度度熊想去商场买一顶帽子，商场里有N顶帽子，有些帽子的价格可能相同。度度熊想买一顶价格第三便宜的帽子，问第三便宜的帽子价格是多少？ 输入描述:首先输入一个正整数N（N &lt;= 50），接下来输入N个数表示每顶帽子的价格（价格均是正整数，且小于等于1000） 输出描述:如果存在第三便宜的帽子，请输出这个价格是多少，否则输出-1 输入例子:1010 10 10 10 20 20 30 30 40 40 输出例子:30 python: 123456789101112131415161718192021#coding=utf-8'''Created on 2017/6/21@author: Administrator'''n=input("")price=raw_input("")price=price.split()price=map(eval, price)price=sorted(price)a=[]a.append(price[0])for i in range(1,n): b=price[i] c=price[i-1] if b&gt;c: a.append(b)if a.__len__()&lt;3: print(-1)else: print a[2] 第二题一个数轴上共有N个点，第一个点的坐标是度度熊现在位置，第N-1个点是度度熊的家。现在他需要依次的从0号坐标走到N-1号坐标。但是除了0号坐标和N-1号坐标，他可以在其余的N-2个坐标中选出一个点，并直接将这个点忽略掉，问度度熊回家至少走多少距离？输入描述:输入一个正整数N, N &lt;= 50。 接下来N个整数表示坐标，正数表示X轴的正方向，负数表示X轴的负方向。绝对值小于等于100 输出描述:输出一个整数表示度度熊最少需要走的距离。 输入例子:41 4 -1 3 输出例子:4 python： 1234567891011121314151617#coding=utf-8import mathn=input('')sum1=raw_input('')sum1=sum1.split()sum1=map(eval, sum1)he=0cha=[]for i in range(1,n): he=he+abs(sum1[i]-sum1[i-1]) for i in range(1,n-1): cha1=abs(sum1[i]-sum1[i-1])+abs(sum1[i+1]-sum1[i])-abs(sum1[i+1]-sum1[i-1]) cha.append(cha1)b=max(cha)c=he-bprint c]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>baidu</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习指南]]></title>
    <url>%2F2017%2F06%2F24%2FGit%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[看了一本《Git学习指南》的书，所以写了这个note，多多学习Git操作，也好装B，以前只会简单几个操作。 基本概念分布式版本控制、有何过人之处集中式概念： 是将项目集中存放在中央服务器中，在工作的时候，大家只在自己电脑上操作，从同一个地方下载最新版本，然后开始工作，做完的工作再提交给中央服务器保存。这种方式需要联网，现在云开发就是这样的处理方式。 分布式概念： 只要提供一台电脑作为版本集中存的服务器放就够了，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它也一样干活，只是交换修改不方便而已。而每一台电脑有各自独立的开发环境，不需要联网，本地直接运行，相对集中式安全系数高很多。 以上的简介和图片均来自网上blog 分布式版本控制的特型版本库 项目版本库：该版本库主要用于存储有“官方”创建并发行的版本 共享版本库：该版本库主要用于开发团队内人员之间的文本交换。 工作流版本库：工作流版本库通常只用于填充那些代表工作流中某些特定进展状态的修改，例如审核通过后的状态等 派生版本库：该版本库主要用于从开发主线分离出某部分内容（例如，分离出那些开发耗时较长，不适合在一个普通发布周期内完成的内容），或者隔离出永远不会被包含在主线中的、用于实验的那部分开发进展。 分布式系统的优点 高性能：几乎所有的操作都不需要进行网络访问，均可直接在本地执行 高效的工作方式：开发者可通过多个本地分支在不同任务之间进行快速切换 灵活的开发进程：我们可以在团队和公司中为其他部门建立专门的版本库，例如为方便与测试人员交流而建的版本库。这样相关修改就会很容易发布，因为只是特定版本库上的一次推送。 备份作用：由于每个开发者都持有一份拥有完整历史版本的版本库副本，所以因服务器故障而导致数据丢失的可能性是微乎其微。 可维护性：对于那些难以对付的重构工作，我们可以在将成功传送给其原始版本库之前，先在该版本库的副本尝试一下。 版本库，分布式工作的基础所在版本库其实就是一个高效的数据存储结构而已，由以下部分组成 文件 目录 版本 对于所有数据，它们会被计算一个十六进制散列值。这个散列值将会被用作相关对象的引用，以及日后恢复数据时所需的键值。 也就是说，一个提交对象的散列值实际上就是它的版本号，如果我们持有某一提交的散列值，就可以用它来检查对应版本是否存在于某一版本库中。如果存在，我们就可以将其恢复到当前工作区相应的目录中。如果该版本不存在，我们也可以从其他版本库中单独导入该提交所引用的全部对象。 散列值和版本库的优点 高性能：通过散列来访问数据时非常快的 冗余度—释放存储空间：相同的文件内容只需存储一次即可 分布式版本号：由于相关散列值是根据文件，作者和日期来计算的，所以版本也可以“离线”产生，不用担心将来会因此而发生版本冲突。 版本库间高效同步：当我们将某一提交从一个版本库传递给另一个版本库，只需要传递那些目标版本库中不存在的对象即可。而正是因为有了散列值的帮助，我们才能很快判断相关对象是否已经存在。 数据完整性：由于散列值是根据数据的内容来计算的，所以我们可以随时通过Git来查看某一散列值是否与相关数据匹配。以检查该数据上可能的意外变化或恶意操作 自动重命名检测：被重命名的文件可以被自动检测到，因为根据该文件内容计算出的散列值并没有发生变化。也正因为如此，Git中并没有专门的重命名命令，只需移动命令即可。 入门准备Git环境去官网安装 去Git官网安装 config命令配置用户名和用户邮箱 git config –global user.email “xxxxx@xxx.com” 第一个Git项目创建版本库init命令，对于一个带版本库的项目目录，通常称之为工作区 git init 首次提交第一步，我们先要用add命令来确定哪些文件应被包含下次提交中。第二步，再用commit命令将修改传送到版本库中，并赋予该提交一个散列值以便标识这次新提交。 git add xx.text git commit –message “xxx” 检查状态 git status status命令就会显示出该项目自上次提交以来所发生的所有修改。 git diff 命令可以显示其每个被修改的行 提交修改接下来，所有修改都必须要被先归档成一次新的提交。我们要对修改过的文件和新文件执行add命令，并对要删除的文件使用rm命令。 git add foo.txt bar.html git rm bar.txt 现在再次调用status命令，我们会看到所有的修改已经被纳入下次提交中。 然后在用commit命令提交这些修改。 显示历史log 命令可用来显示项的历史，所有提交都会按时间顺序被降序排列出来 git log Git 的协作功能克隆版本库 git clone git pull命令可以从原版本库中取回新的修改，将它们与克隆体中的的本地修改进行对比，并在工作区中合并两边的修改，创建一次新的提交。这个过程就是所谓的合并。 创建共享版本库除了可以用pull命令从其他版本库取回相关提交外，我们也可以用push命令将提交传送给其他版本库。 Pull命令：取回修改推送和拉回push和pull命令可用于在本地和远程版本库之间共享版本提交。 提交究竟是什么提交的时候不仅提交被修的文件，它包含该项目的所有文件,针对每次提交，Git都会为其计算一个由40个字符组成的唯一编码,我们称之为提交散列值。只要知道这个散列值，我们就可以将项目中的文件从版本库中恢复到该提交被创建的那个时间点上。在Git中，恢复到某一版本通常被称之为检出(checked)操作。 add命令与commit命令我们可以分add命令和commit命令着两步来创建一次提交 注册修改 我们可以用add命令来进行注册，将所有的修改纳入下次提交。在这里，你可以使用-all参数，这表示我们会将所有修改都纳入在内 git add –all 创建提交 现在可以创建一次新的提交 git commit 在谈提交散列值Git选择散列值的理由 这样的提交散列值可以在本地生成。我们无需与其他计算机或中央服务器进行通信，就可以随时随地创建新的提交。 提交散列值中的信息要比单纯一个软件版本的名称要多得多。 提交历史版本库中所包含的并不仅仅是一个个独立的提交，它同时也存储了这些提交之间的关系。没当我们修改了软件并确认提交时，Git就会记下这个提交之前的版本， 提交之间的差异的比较通过diff命令，我们可以比较出两次提交之间的差异。 同一项目的多部不同历史我们可以通过log命令来显示提交历史 部分输出：-n该选项通常用于限制输出，例如显示最后三次提交 git log -n 3 格式化输出：–format、–oneline对于日志的输出格式，我们可以用–format选项来控制。–oneline选项所显示的概述信息 统计修改信息：–stat、–shortstat统计类选项也是很有用的：–stat可用来显示被修改的那些文件。–dirstat则可以用来显示那些包含被修改文件的目录。而–shortstat则用来显示项目中有多少文件被修改，以及新增或删除了多少文件 日志选项：–graph我们也可以通过–graph选项来显示各提交之间的关系 多次提交提交的产生通常分为两个步骤。首先，我们要用add命令将所有相关的修改纳入到一个缓存区中。这个缓存区通常被叫做暂存区或索引。接着我们才能用commit命令将暂存区中的修改传送到版本库中。 status命令通过status命令，我们可以查看到当前工作区中所发生的修改。以及其中的哪些修改已经被注册到了暂存区中，以作为下次提交的内容。 changes to be committed:被提交的修改，这部分将列出那些将在下次提交中被纳入版本库中的、被修改的文件。 changed but not updated:不会被更新的修改，这部分将列出那些已被修改，但尚未被注册到下次提交中的文件 untracked files:未被跟踪的文件，这部分将列出所有的新增文件 怎样的修改不该被提交 为调试而做的实验性修改 意外添加的修改 尚未准备好的修改 自动生成文件中所发生的修改 从暂存区撤回修改reset命令可用来重置暂存区。其中第一个参数为HEAD，表示的是我们将其重置为当前HEAD版本。第二个参数则用来指定要被重置的文件或目录 用.gitignore忽略非版本控制文件创建一个名为.gitignore文件，文件内的文件就会被忽略 存储情况：如果我们在某些事情进行到中间的时候，突然发现自己需要快速修复某个问题。这个时候，我们通常会希望立即去做相关的修改，但同时先不提交之前一直在做的事情。在这个情况下，我们可以用stash命令先将这些修改保存在本地，日后再处理。 我们通过stash命令将工作区和暂存区中的修改保存在一个被我们称之为储藏栈的缓存区中 我们可以用stash pop命令将栈中所储藏的修改恢复到工作区中 版本库 对象数据库：所有提交中的文件、目录以及相关的元数据将被存储在该数据库 SHA1散列值：我们可以通过一个SHA1散列值从对象数据库中捡取相关对象。SHA1散列值是一种针对文件内容的加密校验植 相同数据只存储一次：内容相同的对象拥有相同的SHA1散列值，并且只存储一次 相同的数据会被压缩：对于内容相似的数据，Git会针对其被修改的部分采取增量存储的方法 Blob对象：文件的内容将会被存储在相应的blob对象中 Tree对象：目录会被存储在相应tree对象中。一个tree对象中通常会包含一份文件名列表，包含这些文件名和存储在blob或tree对象中内容的SHA1散列值 重命名检测：文件的重命名和移动操作在提交之前无需报备。Git可以自动根据文件内容的相似度来识别操作 分支]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础知识]]></title>
    <url>%2F2017%2F06%2F18%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[记录一下:因为上上个学期不好好学习，导致我的信息技术考试考了55分，结果今年又要重修，所以在距离考试还有5天的时间，我得认真复习，因为以后可能就走这个行业，所以还是做好笔记认认真真复习一遍。 TCP/IP介绍简介TCP/IP 中译名为传输控制协议/因特网互联协议，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准，是一组协议族。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台电脑规定一个地址。 OSI模型中，应用层、传输层和数据链路层保证了数据的可靠性。 OSI模型 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 TCP/IP模型 应用层 传输层 网际层 网络接口层 数据封装过程例如发送一封电子邮件 应用层将数据编码成电子邮件并发送给传输层 传输层将信息分段，并在其头部添加控制信息（保证分段在目的地按顺序重组），构成数据段，发送给网际层。 网际层在数据段的IP头部添加IP地址信息，构成数据包，发送给网络接口层 网络接口层在数据包的头部添加MAC地址，构成帧。帧的尾部添加差错检查信息（FCS） 物理层将帧编码成能在介质上传输到目的地的比特流 CISCO设备交换机：二层交换机工作在OSI的数据链路层 ​ 三层交换机同事工作在OSI的数据链路层和网络层 网关：从表面来看工作在三层，实际上网关是一个杂合物，属于所有层都有，七层。 网桥：数据链路层 路由器：网络层 交换机和路由器的区别： 交换机工作在第二层，路由器工作在第三层 交换机使用MAC地址寻址（物理地址），路由器使用IP地址寻址（逻辑地址） 交换机的主要作用将PC连接在一起，而路由器主要作用是路由选择和分割广播域 OSI模型各层介绍物理层物理层功能是利用物理传输介质为数据链路层提供物理连接，以便透明的传输比特流，简单说就是设置网络拓扑结构、比特传输、位同步。 数据表现形式：比特流，这样的叫法叫PDU(协议数据单元) 介质三种介质：铜缆，光纤，无线介质 铜介质：粗缆、细缆、双绞线 拓扑结构物理拓扑：是根据网络设备的实际物理地址进行扫描而得到 类型：bus(总线型)，ring(环状拓扑)，star(星型拓扑)，tree(树型拓扑)，net(网状拓扑) 逻辑拓扑：是以网络设备的IP地址划分为依据生成的拓扑图 类型：广播broadcast，令牌传递/令牌环token-passing 主要设备中继器、集线器 数据链路层数据链路层功能在此层将数据分帧，并处理流控。屏蔽物理层，为网络层提供一个数据链路的链接，在一条有可能出差错的物理连接上，进行几乎无差错的数据传输。本层指定拓扑结果并提供硬件寻址 简单地说就是：成帧、物理寻址、流量、差错控制 数据表示形式：帧 主要设备交换机 交换模式 直通式（Cut Through）：当输入端口检测到一个数据包时，就检查该包的爆头，根据包内的目的地地址把数据包直通到相应的端口。 存储转发式（Store and Forward）：这种方法先将数据包完整的接收下路，经过CRC检查，如果数据包没有错误，在根据地址进行转发。 无碎片转发（Fragment Free）：它检查数据包的长度是否够64字节，若小于64字节，说明是弃包，进行丢弃，若大于64字节，则发送该报 MAC地址(考试重点)表示：6个字节，48个二进制位 MAC地址与Ipv6的联系： MAC地址生成64位主机地址规则： 从左边数第一份倒数第二个字节取反，与第二个字节合写 第三个字节后加ff 第四个字节前面加上fe 第五个和第六个字节合写 例：00-13-D3-02-F7-30 → 0213-D3ff-fe02-F730 注释MAC地址是硬件地址（物理地址），作用在数据链路层，而IP地址是软件地址（逻辑地址），作用在网络层 ARP(地址解析协议)功能：将IP地址解析为对应的MAC地址 考题：两台主机无法通信的原因（ARP角度） 解答：当发送接收双方主机在一个网段时，当一个主机向另一台主机发送通讯时，认为两者在同一网段，这时会进行不断请求，而消息将会发送到错误的目的地，导致无法通讯，解决方法是使用代理ARP。 RARP(逆向地址解析协议)(反向ARP协议) 功能:将MAC地址解析为对应的IP得知 以太网组成：物理层+部分数据链路层，即OSI模型1,2层 网络层网络层功能本层通过寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。它包括通过互联网络开路由和中继数据。 简单来说就是：逻辑寻址，路由选择 数据表示形式：数据包 IP地址 构成：IP地址=网络地址位+主机地址位 作用：识别与定位 分类 A类：0.0.0.0-127.255.255.255 8位网咯地址+24位主机地址 B类：128.0.0.0-191.255.255.255 16位网络地址+16位主机地址 C类：192.0.0.0-223.255.255.255 24位网络地址+8位主机地址 D类：224.0.0.0-239.255.255.255 组播地址 E类： 240.0.0.0-255.255.255.255(其中255.255.255.255为全网广播地址)，E类地址一般用于研究作用 广播地址和网络地址 广播地址：主机位全为1，网络地址：主机位全为0 子网掩码： 定义：网络地址位全为1+主机地址全为0 网络地址=IP地址&amp;子网掩码 表示： /n n为网络地址位长度 /8→255.0.0.0 /9→255.128.0.0 作用：分割子网，将IP地址与子网掩码做与操作，将相同的合并在同一个子网中 IPV6 长度：128位，64位网络地址+64为主机地址 主要设备路由器 传输层传输层功能常规数据递送，两种递送方式：面向连接（TCP）或无连接（UDP）。为会话层用户提供一个端到端的可靠、透明盒优化的数据传输服务机制。包括全双工或半双工、流控制和错误恢复服务。 简单的说就是：端口寻址、分段重组、流量、差错控制 数据表示形式：数据段 两个协议：TCP和UDP TCP：当发送方发送数据段时，发送方需要TCP协议与接收方连接建立会话，采用三次握手的方式，连接后即可建立虚数据进行发送数据通信，使用TCP协议连接时都要建立三次握手原则。 UDP：当发送方发送数据段时，不需要和接收方进行协商联系，也不给数据段标号，直接发送过去，并不关心数据段是否到达接收方 使用TCP协议规则的协议有：FTP HTTP SMTP Telent DNS 使用UDP协议规则的协议有： TFTP SNMP DHCP DNS TCP和UDP优缺点 TCP UDP TCP协议面向连接 UDP协议面向非连接 TCP协议传输速度慢 UDP协议传输速度快 TCP协议采用字节流方式，如果字节流太长，将其分段，保证数据顺序，不出现丢失或乱序 UDP协议不保证，尽最大能力交付 TCP协议对系统资源要求多 UDP协议要求少 TCP协议保证数据正确性，超时重发，丢弃重复数据，有可靠性 UDP协议可能丢包 TCP协议提供端到端、全双工通信 UDP协议是广播式的 三次握手原理（考试重点）TCP是因特网中的传输层协议，使用三从握手协议建立连接，这种建立连接的方法可以防止产生错误的连接。 字段含义： ACK 确认字段 SYN 同步序列号 过程 第一次握手：建立连接时，客户端发送syn数据段到服务器，并等待服务器确认。 第二次握手：服务器收到syn数据段，从而建立于客户端的会话，为了确认收到客户的SYN包，同时自己也发送一个SYN数据段，即SYN+ACK， 第三次握手：客户端收到服务器的SYN+ACK数据段，向服务器发送包含ACK数据段，此数据段发送完毕后，客户端和服务器进入TCP连接成功状态，完成三次握手。 会话： 两种状态：创建会话(采用三次握手)，终止(发送FIN消息) 应用层会话层功能 在两个节点之间建立端连接，为端系统的应用程序之间提供了对话控制机制。此服务包括建立连接时以全双工还是以半双工的方式进行设置。 简单地说就是：对话控制，建立同步 表示层功能主要用于处理两个通信系统中交换信息的表示方式。为上层用户解决用户信息的语法问题。它包括数据格式交换、数据加密与解密、数据压缩与恢复等 简单地说就是：翻译、加密、压缩 应用层功能为特定类型的网络应用提供了访问OSI环境的手段。应用层确定进程之间通信的性质，以满足用户的需要。应用层不仅要提供应用程序所需要的信息交换和远程操作，而且还要作为应用进程的用户代理，来完成一些为进行信息交换所必需的功能。它包括：文件传送访问和管理FTAM，虚拟终端VT、事物处理TP、远程数据库访问RDA、制造业报文规范MMS、目录服务DS等协议 简单地说就是文件传输、电子邮件、文件服务、虚拟终端‘ 三层的数据表现形式：一般称为消息 TCP/IP模型应用层协议这个就不详细讲了 TCP/IP模型应用层协议端口 协议 端口 采用协议 文件传输协议(FTP)数据 20 TCP 文件传输系诶(FTP)控制 21 TCP Talnet(远程登录) 23 TCP 简单邮件传输协议(SMTP) 25 TCP 简单文件传输协议(TFTP) 69 UDP 超文本传输协议(HTTP) 80 TCP 域名系统(DNS) 53 TCP/UDP 邮局协议(POP3) 110 TCP 安全的HTTP(HTTPS) 443 TCP 思科考试重点：填空题： 在以太网中，ip的作用是识别和定位。 TCP通过使用流量控制和滑动窗口来提供阻塞控制 对于在不同网段的两台主机，在数据的传输过程中，从源主机发送后，到目的主机接收前，数据所经过的OSI模型的最高层是网络层 ipconfig 查找网关IP地址，tracert追踪用于返回数据包在网络中传输时，沿途经过的跳列表，即追踪从源主机到目的主机所经过的路由器地址，nslookup 手动查询域名服务器指令 各层的协议 应用层： DNS HTTP SMTP(简单邮件传输协议) POP POP3 Telent DHCP(动态主机配置协议) FTP 网际层协议 ARP RARP ICMP 传输层协议 TCP UDP ping不通目的主机各层可能发生的错误 物理层故障：线缆短路，接口故障，速率、双工状态不一致 数据链路层：数据帧的封装格式不同 网路层：没有安装相应协议，没有设置正确IP地址。 网页无法连接各层可能发生的错误 物理层故障：网线松动，接口故障 数据链路层：设备配置错误，设备没有安装驱动程序，例如网卡驱动 网络层：IP地址是否配置正确，子网掩码是否正确，网关是否正确，DNS或DHCO设置是否正确 传输层：防火墙设置错误，应用程序的TCP或UDP端口是否被打开 会话层、表示层、应用层：应用软件故障。 题目：请以OSI七层模型为例，说明在网络通信过程中，如何保证数据的可靠性 传输层 ：滑动窗口，序列号，确认 数据链路层 ：帧检测序列FCS 应用层：校验文件类型 题目：210.34.160.0/24网段分成两个字网，由于客户端(client)子网掩码设置错误,都设成255.255.255.0，造成两个子网不能正常通信，请解释 子网掩码的作用 定义地址的网络和主机部分，子网划分 不能通信的原因（从ARP的角度） 当发送接收双方主机在一个网段时，当一个主机向另一台主机发送通讯时，认为两者在同一网段，这时会进行不断请求，而消息将会发送到错误的目的地，导致无法通讯 题目：请解释数据到传输层后，物理层前，这些层对数据封装 传输层分割数据，成段 网络层：加上相应的IP报头 数据链路层加上报尾形成帧 题目·数据在各个阶段的PDU 物理层：比特流 bit 数据链路层：帧frame 网络层：数据包packet 传输层：数据段segment]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3实战笔记]]></title>
    <url>%2F2017%2F06%2F10%2FCSS3%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3]]></title>
    <url>%2F2017%2F06%2F08%2FCSS3%2F</url>
    <content type="text"><![CDATA[CSS3初步认识CSS3简介CSS3模块一些重要的CSS3模块 选择器 盒模型 背景和边框 文字特效 2D/3D转换 动画 多列布局 用户界面 CSS3边框CSS3圆角在CSS3中border-radius属性被创建圆角 CSS3盒阴影在CSS3中添加box-shadow属性 实例 123div&#123; box-shadow: 10px 10px 5px #888888;&#125; CSS3边界图片你可以使用图像创建一个边框 CSS3 圆角CSS3 border-radius -指定每个圆角CSS33背景CSS3背景属性： background-image background-size background-origin background-clip CSS3 background-image属性CSS3中可以通过background-image属性添加背景图片。 不同的背景图像用逗号隔开，所有图片中显示在最顶端(最顶层)的为第一张。 实例： 12345#example&#123; background-image: url(img_flwr.gif),url(paper.gif); background-position: right bottom,left top; backgrond-repeat: no-repeat, repeat;&#125; CSS3 background-size属性background-size指定背景图像的大小 你也可以指定像素或百分比大小，指定的大小是相对于父元素的宽度和高度的百分比的大小 CSS3 background-Origin属性background-Origin属性指定了背景图像的位置区域 content-box，padding-box和border-box区域内可以放置背景图片 CSS3 background-clip属性 CSS3中background-clip背景剪裁属性是从指定位置开始绘制的 content-box，padding-box和border-box三个可选参数 CSS3渐变CSS3定义了两种类型的渐变 线性渐变-向下/向上/向左/向右/对角方向 径向渐变-由它们的中心定义 使用透明度CSS3渐变也支持透明度，可以创建减弱变淡的效果。 CSS3文本效果 text-shadow box-shadow text-overflow（文本溢出） word-wrap(单词换行) word-break（文本拆分换行） CSS3字体使用你需要的字体在新的@font-face规则中，你必须首先定义字体的名称，然后指向该字体文件。 如需为HTML元素使用字体，请通过font-family属性来引用字体的名称 123456789&lt;style&gt;@font-face&#123; font-family: myFirstFont; src: url(sansation_light.woff);&#125;div&#123; font-family: myFirstFont;&#125;&lt;/style&gt; CSS3 2D转换 translate()移动 rotate()旋转 scale()元素的增减 skew()坐标轴的倾斜角度 matrix()包含上面所有功能 CSS3 3D转换 rotateX() rotateY() CSS3过渡它是如何工作？CSS3过渡是元素从一种样式改变为另一种的效果。 要实现这一点，必须规定两项内容： 指定要添加效果的CSS属性 指定效果的持续时间 实例： 123456div&#123; transition-property: width; transition-duration: 1s;//过渡效果花费的时间1s transition-timing-function: linear;//规定过渡效果的时间曲线 transition_delay: 2;//延迟2秒执行&#125; CSS3动画CSS3@keyframes规则@keyframes规则是创建动画。@keyframes规则内指定一个CSS样式和动画将逐步从目前的样式更改为新的样式。 CSS3动画当在@keyframes创建动画，把它绑定到一个选择器，否则动画不会有任何效果。指定至少这两个CSS3的动画属性绑定向一个选择器： 规定动画的名称 规定动画的时长 CSS3动画是什么？动画是使元素从一种样式逐渐变化为另一种的效果。 你可以改变任意多的样式任意多的次数， 请用百分比来规定变化发生的时间，或用关键词“from”和“to“，等同于0%和100%。 0%是动画开始，100%是动画的完成 CSS3多列CSS3多列属性 column-count column-gap column-rule-style column-rule-width column-rule-color column-rule column-span column-width CSS3 创建多列column-count属性指定了需要分割的列数。 CSS3列与列的间隙column-gap属性指定了列与列间的间隙 CSS3列边框column-rule-style 属性指定了列与列间的边框样式。 column-rule-width属性指定了两列的边框厚度 column-rule-color属性指定两列的边框颜色 指定元素跨越多少列指定列的宽度column-width属性指定了列的宽度 CSS3用户界面 resize box-sizing outline-offset CSS3 调整尺寸CSS3中，resize属性指定一个元素是否应该由用户去调整大小 CSS3 方框大小调整box-sizing属性允许你以确切的方式定义适应某个区域的具体内容 CSS3外形修饰outline-offset属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。 轮廓与边框有两点不同： 轮廓不占用空间 轮廓可能是非矩形 CSS3图片响应式图片响应式图片会自动适配各种尺寸的屏幕 实例： 1234img&#123; max-width: 100%; height: auto;&#125; 图片滤镜CSS filter属性可为元素添加可是效果（例如模糊或饱和度）]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5 初步认识]]></title>
    <url>%2F2017%2F06%2F03%2Fhtml5-%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[HTML5简介什么是HTML5？ HTML5是下一代HTML标准 HTML，HTML4.01的上一个版本诞生于1999年。自从那以后，WEB世界已经经历了巨变、 HTML5仍处于完善中，然而，大部分现代浏览器已经具备了某些HTML5支持 HTML5是如何起步的HTML5的一些有趣的特性: 用于绘画的canvas元素 用于媒介回访的video和audio元素 对本地离线存储的更好的支持 新的特殊内容元素,不如article、footer、header、nav、section 新的表单控件，比如calendar、date、time、email、url、search HTML5 &lt; !DOCTYPE&gt;&lt;!doctype&gt;声明必须位于HTML5文档中的第一行，使用非常简单 1&lt;!DOCTYPE html&gt; HTML5的改进 新元素 新属性 完全支持CSS3 Video和Audio 2D/3D制图 本地存储 本地SQL数据 Web应用 HTML5 多媒体使用HTML5你可以简单的在网页中播放视频（video）与音频（audio）。 HTML5 &lt;video&gt; HTML5 &lt;audio&gt; HTML5 应用使用HTML5你可以简单地开发应用 本地数据存储 访问本地文件 本地SQL数据 缓存引用 JavaScript工作者 XHTMLHttpRequest2 HTML5 使用CSS3 新选择器 新属性 动画 2D/3D转换 圆角 阴影效果 可下载的字体 语义元素 标签 描述 &lt;article&gt; 定义页面独立的内容区域 &lt;aside&gt; 定义页面的侧边栏内容 &lt;bdi&gt; 允许你设置一段文本，使其脱离其父元素的文本方法设置 &lt;command&gt; 定义命令按钮，比如单选按钮、复选框或按钮 &lt;dialog&gt; 定义对话框，比如提示框 &lt;summary&gt; 标签包含details元素的标题 &lt;figure&gt; 规定独立的流内容（图像、图表、照片、代码等） &lt;figcaption&gt; 规定&lt;figure&gt;元素的标题 &lt;footer&gt; 规定section或document的页脚 &lt;header&gt; 规定了文档的头部区域 &lt;mark&gt; 定义带有记号的文本 &lt;meter&gt; 定义度量衡。仅用于已知最大和最小值的度量 &lt;nav&gt; 定义导航链接的部分 &lt;progress&gt; 定义任何类型的任务的进度 &lt;ruby&gt; 定义ruby注释 &lt;rt&gt; 定义字符的解释或发音 &lt;section&gt; 定义文档中的节 &lt;time&gt; 定义日期或时间 &lt;wbr&gt; 规定在文本中的何处适合添加换行符 HTML5表单新表单元素，新属性，新输入类型，自动验证 将HTML5元素定义为块元素HTML5定义8个新的HTML语义元素。所有这些元素都是块级元素 为了能让旧版本的浏览器正确显示这些元素，你可以设置CSS的display属性值为block 123header,section,footer,aside,nav,main,article,figure&#123; display:block;&#125; HTML5新元素canvas新元素标签定义图形，比如图表和其他图像。该标签基于JavaScript的绘图API 新多媒体元素 标签 描述 &lt;audio&gt; 定义音频内容 &lt;video&gt; 定义视频 &lt;source&gt; 定义多媒体资源&lt;video&gt;和&lt;audio&gt; &lt;embed&gt; 定义嵌入的内容，比如插件 &lt;track&gt; 位诸如&lt;video&gt;和&lt;audio&gt;元素之类的媒介规定外部文本轨道 新表单元素 标签 描述 &lt;datalist&gt; 定义选项列表。请与input元素配合使用该元素，来定义input可能的值 &lt;keygen&gt; 规定用于表单的密钥对生成器字段 &lt;output&gt; 定义不同类型的输出，比如脚本的输出 已经移除的元素 &lt;acronym&gt; &lt;applet&gt; &lt;basefont&gt; &lt;big&gt; &lt;center&gt; &lt;dir&gt; &lt;font&gt; &lt;frame&gt; &lt;frameset&gt; &lt;noframes&gt; &lt;strike&gt; &lt;tt&gt; HTML5 Canvas &lt;canvas&gt;标签定义图形，比如图表和其他图像，你必须使用脚本来绘制图形 创建一个画布（Canvas）简单实例： 1&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt; 注意：标签通常需要制定一个id属性（脚本中经常）,width和height属性定义的画布的大小 使用JavaScript来绘制图像canvas元素本身是没有绘图能力的。所有的绘制工作必须在JavaScript内部完成。 实例： 1234var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.fillStyle=&quot;#FF0000&quot;；ctx.fillRect(0,0,150,75); 分析 首先，找到&lt;canvas&gt;元素 然后创建context对象 getContext(“2d”)对象是内建的HTML5对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 设置fillStyle属性可以是CSS颜色，渐变、或图案。fillStyle默认设置是#000000(黑色) fillRect(x,y,width,height)方法定义了矩形当前的填充方式 Canvas 坐标canvas的左上角坐标为（0,0） 上面的fillRect方法拥有参数(0,0,150,75). 意思是：在画布上绘制150×75的矩形，从左上角(0,0)开始。 Canvas-路径在Canvas上画直线，可以使用以下两种方法： moveTo(x,y)定义线条开始坐标 lineTo(x,y)定义线条结束坐标 绘制线条我们必须使用“ink”方法，就像stroke()方法来绘制线条 12345var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.moveTo(0,0);ctx.lineTo(200,100);ctx.stroke(); 在canvas绘制圆形 arc(x,y,r,start,stop) 12345var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();ctx.arc(95,50,40,0,2*Math.PI);ctx.stroke(); Canvas-文本使用canvas绘制文本，重要的属性和方法如下： font-定义字体 fillText(text,x,y)-在canvas上绘制实心的文本 strokeText(text,x,y)- 在canvas上绘制空心的文本 Canvas-渐变渐变可以填充周期矩形，圆形，线条，文本等等，各种形状可以自己定义不同的颜色。 以下有两种不同的方式来设置Canvas渐变： createLinearGradient(x,y,x1,y1)-创建线条渐变 createRadialGradient(x,y,r,x1,y1,r1)-创建一个径向/圆渐变 当我们使用渐变对象，必须使用两种或两种以上的停止颜色。 addColorStop()方法指定颜色停止，参数使用坐标来描述，可以使0至1 使用渐变，设置fillStyle或strokeStyle的值为渐变，然后绘制形状，如矩形，文本，或一条直线。 1234567var c=document.getElementById(&quot;myCanvas&quot;);var context=c.getContext(&quot;2d&quot;);var grd=context.createLinearGradient(0, 0, 200, 0);grd.addColorStop(0, &apos;red&apos;);grd.addColorStop(1, &apos;blue&apos;);context.fillStyle=grd;context.fillRect(10,10,150,80); Canvas-图像把一幅图像放置到画布上，使用以下方法： drawImage（image,x,y) HTML5 内联SVG什么是SVG SVG指可伸缩矢量图形 SVG用于定义用于网络的基于矢量的图形 SVG使用XML格式定义图形 SVG图像在放大或改变尺寸的情况下其图形质量不会有损失 SVG是万维网联盟的标准 SVG的优势与其他图像格式相比，使用SVG的优势： SVG图像可以通过文本编辑器来创建和修改 SVG图像可被搜索、索引、脚本化或压缩 SVG是可伸缩的 SVG图像可在任何的分辨率下被高质量地打印 SVG可在图像质量不下降的情况下被放大 SVG与Canvas的区别 SVG是一种使用XML描述2D图形的语言。 Canvas通过JavaScript来绘制2D图形 SVG基于XML，这意味着SVG DOM中的每个元素都是可用的。你可以为某个元素附加JavaScript事件处理器 在SVG中每个被绘制的图形均被视为对象。如果SVG对象的属性发火说呢过变化，那么浏览器能够自动重现图形 Canvas是逐像素进行渲染的。在canvas中，一旦图形被绘制完成，它就不会继续得到浏览器关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或已被图形覆盖的对象 Canvas SVG 依赖分辨率 不依赖分辨率 不支持事件处理器 支持事件处理器 弱的文本渲染能力 最适合带有大型渲染区域的应用程序（比如谷歌地图） 能够以.png或。jpg格式保存结果图形 复杂度高会减慢渲染速度 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 不适合游戏应用 HTML5 MathMLHTML5可以再文档中时MathML元素，对应的标签是\ MathML是数学标记语言，是一种基于XML的标准，用来在互联网上书写数学符号和公式的置标语言 Chrome浏览器不能用，火狐可以 HTML5 拖放拖放(Drag和Drop)是HTML5标准的组成部分 拖放拖放是一种常见的特性，即抓取对象以后拖到另一个位置 在HTML5中，拖放是标准的一部分，任何元素都能够拖放。 实例: 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;#div1 &#123;width:350px;height:70px;padding:10px;border:1px solid #aaaaaa;&#125;&lt;/style&gt;&lt;script&gt;function allowDrop(ev)&#123; ev.preventDefault();&#125; function drag(ev)&#123; ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125; function drop(ev)&#123; ev.preventDefault(); var data=ev.dataTransfer.getData(&quot;Text&quot;); ev.target.appendChild(document.getElementById(data));&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;拖动 RUNOOB.COM 图片到矩形框中:&lt;/p&gt; &lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;img id=&quot;drag1&quot; src=&quot;/images/logo.png&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; width=&quot;336&quot; height=&quot;69&quot;&gt; &lt;/body&gt;&lt;/html&gt; 解析： 设置元素为可拖放首先，为了使元素可拖动，把draggable属性设置为true： 1&lt;img draggable=&quot;true&quot;&gt; 拖动什么-ondragstart和setDate()然后，规定元素被拖动时，会发生什么。 在上面例子上，ondragstart属性调用一个函数，drag(event),规定了被拖动的数据。dataTransfer.setDate()方法设置被拖数据的数据类型和值： 123function drag(ev)&#123; ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125; 这个例子中，数据类型是“Text”,值是可拖动元素的id(“drag1”) 放在何处- ondragoverondragover事件规定在何处放置被拖动的数据， 默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。 这要通过调用ondragover事件的event.preventDefault()方法： 1event.preventDefault() 进行放置- ondrop当放置被拖数据时，会发生drop事件 在上面例子中，ondrop属性调用一个函数，drop(event): 12345function drop(ev)&#123; ev.preventDefault(); var data=ev.dataTransfer.getData(&quot;Text&quot;); ev.target.appendChild(document.getElementById(data));&#125; 解释： 调用preventDefault()来避免浏览器对数据的默认处理 通过dataTransfer.getData(“Text”)方法获得被拖数据。该方法将返回在setData()方法中设置为相同类型的任何数据。 被拖数据是被拖元素的id(“drag1”) 把被拖元素追加到放置元素中 HTML5 Geolocation(地理定位)HTML5 Geolocation用于定位用户的位置。 HTML5-使用地理定位使用getCurrentPosition()方法来获取用户的位置 实例 123456789101112var x=document.getElementById(&quot;demo&quot;);function getLocation()&#123; if(navigator.geolocation)&#123; navigator.geolocation.getCurrentPosition(showPosition); &#125; else&#123; x.innnerHTML=&quot;该浏览器不支持获取地理位置&quot; &#125;&#125;function showPosition(position)&#123; x.innerHTML=&quot;维度：&quot;+position.coords.latitude+&quot;&lt;br&gt;经度：&quot;+position.coords.longitude;&#125; 检测是否支持地理定位 如果支持，则运行getCurrentPosition()方法，如果不支持，则向用户显示一段消息。 如果getCurrentPosition()运行成功，则向参数showPosition中规定的函数返回一个coordinates对象。 showPosition()函数获得并显示经度和纬度 上面例子是一个非常基础的地理位置定位脚本，不含有错误处理 处理错误和拒绝getCurrentPosition()方法第二个参数用于处理错误，： 123456789101112131415161718function showError(error)&#123; switch(error.code) &#123; case error.PERMISSION_DENIED： x.innerHTML=&quot;用户拒绝获取地理位置的请求。&quot; break; case error.POSITION_UNAVAILABLE: x.innerHTML=&quot;位置信息不可用的。&quot; break; case error.TIMEOUT: x.innerHTML=&quot;请求用户地理位置超时&quot; break; case error.INKNOWN_ERROR: x.innerHTML=&quot;未知错误&quot; break; &#125;&#125; HTML5 VideoHTML5 提供了播放音频文件的标准。 HTML5 Audio - 如何工作实例： 12345&lt;audio controls&gt; &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;&gt; 你的浏览器不支持audio元素&lt;/audio&gt; control属性供添加播放、暂停和音量控件 在&lt;audio&gt;与&lt;/audio&gt;之间你需要插入浏览器不支持的&lt;audio&gt;元素的提示文本 HTML5 Audio 标签 标签 描述 &lt;audio&gt; 定义了声音内容 &lt;source&gt; 规定了多媒体资源，可以是多个，在&lt;video&gt;与&lt;audio&gt;之间使用 HTML5 input类型 color date datetime datetime-local email month number range search tel time url week HTML5 表单元素HTML5新的表单元素 &lt;datalist&gt; &lt;keygen&gt; &lt;output&gt; HTML5&lt;datelist&gt;元素&lt;datelist&gt;元素规定输入域的选项列表。 &lt;datelist&gt;属性规定form或input域应该拥有自动完成功能。当用户在自动完成于域中开始输入时，浏览器应该在该域中显示填写的选项： 使用&lt;input&gt;元素的列表属性与&lt;datalist&gt;元素绑定 实例 12345678&lt;input list=&quot;browsers&quot;&gt;&lt;datalist id=&quot;browsers&quot;&gt; &lt;option value=&quot;Internet Explorer&quot;&gt; &lt;option value=&quot;Firefox&quot;&gt; &lt;option value=&quot;Chrome&quot;&gt; &lt;option value=&quot;Opera&quot;&gt; &lt;option value=&quot;Safari&quot;&gt;&lt;/datalist&gt; HTML5&lt;keygen&gt;元素&lt;keygen&gt;元素的作用是提供一种验证用户的可靠方法。 规定用于表单的密钥对生成器字段 HTML5&lt;output&gt;元素&lt;output&gt;元素用于不同类型的输出，比如计算或脚本输出 HTML5 表单属性HTML5的&lt;form&gt;和&lt;input&gt;标签添加了几个新属性。 &lt;form&gt;新属性 autocomplete novalidate &lt;input&gt;新属性 autocomplete autofocus form formaction formenctype formmethod formnovalidate formtarget height与width list min与max multiple pattern（regexp） placeholder required step form/input autocomplete属性autocomplete属性规定form或input域应该拥有自动完成功能。 当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项。 autocomplete适用于&lt;form&gt;标签，以及以下类型的&lt;input&gt;标签：text，search，url，telephone，email。passsword，datepickers，range以及color novalidate属性novalidate属性石一个boolean属性 novalidate属性规定在提交表单时不应该验证form或input域 autofocus属性autofocus属性是一个boolean属性。 autofocus属性规定在页面加载时，域自动地获得焦点 实例： 1First name:&lt;input type=&quot;text&quot; name=&quot;fname&quot; autofocus&gt; form属性form属性规定输入域所属的一个或多个表单 formaction属性The formaction属性用于描述表单提交的URL地址 The formaction属性会覆盖\元素中的action属性 formenctype属性formenctype属性描述了表单提交到服务器的数据编码(只对form表单中method=“post”表单) formmethod属性formmethod属性定义了表单提交的方式 formmethod属性覆盖&lt;form&gt;元素的method属性 该属性可以与type=“submit”和type=“image”配合 formnovalidate属性novalidate属性石一个boolean属性 novalidate属性描述了&lt;input&gt;元素在表单提交时无需被验证。 formnovalidate属性会覆盖&lt;form&gt;元素的novalidate属性 注意：formnovalidate属性与type=“submit”一起使用 formtarget属性formtarget属性指定一个名称或一个关键字来指明表单提交数据接收后的展示。 formtarget属性会覆盖&lt;form&gt;元素的target属性 height和width属性height和width属性规定用于image类型的&lt;input&gt;标签的图像高度和宽度 list属性list属性规定输入域的datalist。datalist是输入域的选项列表 min和max属性min、max和step属性用于包含数字或日期的input类型规定限定 pattern属性pattern属性描述了一个正则表达式用于验证&lt;&lt;input&gt;元素的值 placeholder属性 placeholder属性提供了一宗提示，描述输入域所期待的值 required属性required属性是一个boolean属性 required属性规定必须在提交之前填写输入域（不能为空） step属性step属性为输入域规定合法的数字间隔。 HTML5的语义元素什么是语义元素？ 一个语义元素能够清楚的描述其意义给浏览器和开发者。 section元素 section标签定义文档中的节。比如章节、页眉、页脚或文档中其他部分 article元素 article标签定义独立的内容 nav元素 nav标签定义导航链接的部分 aside元素 aside标签定义页面主区域之外的内容(比如侧边栏) header元素 header元素描述了文档的头部区域 header元素注意用于定义内容的介绍展示区域 footer元素 footer元素描述了文档的底部区域 HTML5 Web存储什么是HTML5 Web存储使用HTML5可以在本地存储用户的浏览数据 localStorage和sessionStorage客户端存储数据的两个对象为： localStorage -没有时间限制的数据存储 sessionStorage -针对一个session的数据存储 localStorage对象localStorage对象存储的数据没有时间限制。 sessionStorage对象sessionStorage方法针对一个session进行数据存储。当用户关闭浏览器窗口后，数据会被删除 HTML5 应用程序缓存 使用HTML5，通过创建cache manifest文件，可以轻松创建web应用的离线版本。 什么是应用程序缓存(Application Cache) HTML5 引入了应用程序缓存，这意味着web应用可以进行缓存，并可在没有因特网连接时进行访问。应用程序缓存为应用带来三个优势： 离线浏览 用户可在应用离线时使用它们 速度 已缓存资源加载会很快 减少服务器负载 浏览器将只从服务器下载更新过或更改过的资源。 实例： 123456&lt;!DOCTYPE HTML&gt;&lt;html manifest="demo.appcache"&gt;&lt;body&gt; 文档内容&lt;/body&gt; &lt;/html&gt; Cache Manifest基础如需启用应用程序缓存，请在文档的&lt;html&gt;标签中包含manifest 属性； 每个指定了manifest的页面在用户对其访问时都会被缓存。如果未指定manifest属性，则页面不会被缓存。 manifest文件的建议的文件扩展名是：”.appcache”。 Manifest 文件mainfest文件是简单的文本文件，它告知浏览器被缓存的内容(以及不缓存的内容)。 manifest文件可分为三个部分： CACHE MANIFEST -在此标题下列出的文件将在首次下载后进行缓存 NETWORK -在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK -在此标题列出的文件规定在当前页面无法访问时的回退页面(比如404页面) CACHE MANIFEST基本格式 CHAHE MANIFEST /theme.css /logo.gif /main.js 上面的manifest文件列出三个资源：一个CSS文件，一个GIF图像，以及一个JavaScript文件。当manifest文件加载后，浏览器会从网站的根目录下载这三个文件。然后，无论用户何时与因特网断开连接，这些资源依然是可用的。 NETWORK下面的NETWORK小节规定文件”login.php”永远不会被缓存，且离线时不可用的： NETWORK: login.php 可以使用星号来指定所有资源/文件都需要因特网连接： NETWORK: * FALLBACK下面的FALLBACK小节规定如果无法建立因特网连接，则用”offline.html“替代/html5/目录中的所有文件： FALLBACK： /html/offline.html 注意：第一个URL是资源，第二个是替补。 更新缓存一旦应用被缓存，它就会保持缓存知道发生下列情况： 用户情况浏览器缓存 manifest文件被修改 有程序来更新应用缓存 HTML5 Web Workersweb worker是运行在后台的JavaScript，不会影响页面的性能。 计数器的创建工程：创建web worker文件首先，在一个外部JavaScript中创建我们的web worker。 在这里我们创建计数脚本，该脚本存储于”demo_worker.js”文件中： 1234567var i=0;function timeCount()&#123; i=i+1; postMessage(i); setTimeout("timeCount()",500);&#125;timeCount(); postMessage()方法用于向HTML页面传回一段消息 创建Web Worker对象我们已经有web worker文件，现在我们需要从HTML页面调用它。 下面的代码检测是否存在worker，如果不存在，它会创建一个新的web worker对象，然后运行”demo_worker.js”中的代码 1234if(typeof(W)=="undefined") &#123; w=new Work("demo_worker.js") &#125; 然后我们就可以从web worker发生和接收消息了。 向web worker添加一个”onmesssage”事件监听器 123w.onmessage=function(event)&#123; document.getElementById("result").innerHTML=event.data;&#125;; 终止Web Worker当我们创建web worker对象后，它会继续监听消息知道其被终止为止。如需终止web worker，并释放浏览器/计算机资源，请使用terminate()方法： 1w.terminate(); Web Worker和DOM由于web worker位于外部文件中，它们无法访问下例JavaScript对象： window对象 document对象 parent对象 HTML5 服务器发送事件HTML5服务器发送事件允许网页获得来自服务器的更新 Server-Sent事件 -单向消息传递Server-Sent事件指的是网页自动获取来自服务器的更新 接收Server -Sent事件通知EventSource对象用于接收服务器发送事件通知： 12345var source=new EventSource("demo_see.php");source.onmessage=function(event)&#123; document.getElementById("result").innerHTML+="&lt;br&gt;" &#125; EventSource对象 事件 描述 onopen 当通往服务器的连接被打开 onmessaged 当接收到消息 onerror 当发生错误 HTML5 WebSocket 这个等下次认真搞一遍 WebSocket是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JSON必知必会》读书笔记]]></title>
    <url>%2F2017%2F05%2F25%2Fjson%2F</url>
    <content type="text"><![CDATA[将之前写在onenote的关于json的简要知识点改写成md。 第一章 什么是JSON JSON指的是JavaScript对象表示法（JavaScript Object Notation） JSON是轻量级的文本数据交换格式 JSON独立于语言 JSON具有自我描述性，更易理解 JSON使用JavaScript语法来描述数据对象，但是JSON独立于语言和平台。JSON解析器和JSON库之处许多不同的编程语言。目前非常多的动态（PHP、JSP、.NET）编程语言都支持JSON。 第二章 JSON的语法JSON中的名称—值对的名称如果被系统作为对象装入内存的话，将会成为”属性“，不同于名称，值并不是总是需要被双引号包裹。当值是字符串时，必须使用双引号。而在JSON中，数字、布尔值、数组、对象、null等其他类型，这些都不应该被双引号包裹。 例如： 12345678910111213&#123; title："this is my title"&#125;//不合法&#123; 'title':'this is my title'&#125;//同样不合法&#123; "title":"this is my title"&#125;//合法的书写&#123; "value":12 "result":true&#125;//这些都不加双引号 JSON的名称始终被双引号包裹 JSON文件使用.json扩展名 第三章 JSON的数据结构JSON的数据类型： 对象 字符串 数字 布尔值 null 数组 基本嵌套格式 1234567891011121314&#123; "person":&#123; "name":"Lindasy Bassett", "heightInInches":66, "head":&#123; "hair":&#123; "color":"light blood", "length":"short", "style":"A-line" &#125;, "eyes":"green" &#125; &#125;&#125; 注意事项： 遇到双引号、反斜线、\/（正斜线）、\b、\f、\t、\n、\r都需要进行转义（加\） 在JSON中布尔值仅能用true和false表示，任何其他形式的写法都会报错（所有字母必须要小写）。 对象和数组很关键的一个区别就是，对象是名称-值对构成的列表或者集合，数组是值构成的列表或者集合。 对象和数组另一个关键的区别是，数组中所有的值应具有相同的的数据类型。 第四章 JSON Schema基础概念 jsonschema是描述你的JSON数据格式；JSON模式（应用程序/模式+ JSON）有多种用途，其中之一就是实例验证。验证过程可以是交互式或非交互式的。例如，应用程序可以使用JSON模式来构建用户界面使互动的内容生成除了用户输入检查或验证各种来源获取的数据。 基本格式 12345678910111213141516&#123; "schema":"http://json-schame.org/draft-04/shema", "title":"Cat",//文件标题 "properties":&#123; "name":&#123; "type":"string" &#125;, "age":&#123; "tyep":"number", "description":"Your cat's age in year" &#125;, "declawd":&#123; "type":"boolean" &#125; &#125;&#125; “required”，值为一个数组，数组中含必填的字段。如果你的JSON Schema中不含”required“名称–值对，那么将不必有必填项。 总结： JSON Schema是数据交换中的一种虚拟的”合同“ JSON验证器负责验证语法错误，JSON Schema负责提供一致性检验 JSON Schema可以解决下列有关一致性检验的问题。 ——值的数据类型是否正确？ ​ 可以具体规定一个值是数字、字符串等类型 ——是否包含所需要的数据 可以具体规定哪些数据是需要的，哪些是不需要的 ——值的形式是否是我需要的？ 可以指定范围、最小值、最大值。 第六章 JavaScript中的XMLHTTPRequest与Web API基本格式 12345678910var xml=new XMLHTTPRequest();var url="#";xml.onreadystatechange=function()&#123; if(xml.readyState===4 &amp;&amp; xml.state===200)&#123; var myObject = JSON.parse(xml.responseText); var myJSON = JSON.stringify(myObject); &#125;&#125;xml.open("GET",url,true);xml.send(); JSON.parse:反序列化操作，JSON解析成JavaScript对象 JSON.stringify:序列化操作，将JavaScript对象解析成JSON JavaScript中的XMLHttpRequest负责在客户端发起请求，而web API负责在服务端返回响应 XMLHTTPRequest主要属性含义 onreadystatechange 可以在代码中给它赋值为一个函数 readyState 返回一个0~4的值，用来表示状态码 status 返回Http状态码（如200请求表示成功） responseText 当请求成功时，该属性会包含作为文本的响应体 ​]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS高程复习]]></title>
    <url>%2F2017%2F05%2F25%2FJS%E9%AB%98%E7%A8%8B%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[&ensp; 之前在学JS基础的时候已经刷过一次，只不过上次很多东西没错，最近忙于暑期实习，所以特意又将这本书再刷一遍，在仔细作一遍笔记，把之前遗落的知识点重新学习一下。主要记一点面试的知识点。 17/5/25 第一章 JavaScript简介JavaScript实现一个完整的JavaScript实现包括三个不同的部分组成 核心(ECMAScript) 文档对象模型(DOM) 浏览器对象（BOM） ECMAScript即是JS的标准，目前已经到ES6。 DOM简单理解就是HTML内容 第二章 在HTML中使用JavaScript&lt;\script&gt;元素标签的位置 html文件是自上而下的执行方式，但引入的css和javascript的顺序有所不同，css引入执行加载时，程序仍然往下执行，而执行到&lt;\script&gt;脚本是则中断线程，待该script脚本执行结束之后程序才继续往下执行。所以，一般将script放在body之后是因为避免长时间执行script脚本而延迟阻塞。而有一些页面的效果的实现，是需要预先动态的加载一些js脚本，所以这些脚本应该放在&lt;\body&gt;之前。其次，不能将需要访问dom元素的js放在body之前，因为此时还没有开始生成dom，所以在body之前的访问dom元素的js会出错，或者无效。就是因为这个，在dom没生成好时我就给它添加了方法，才导致这样 延迟脚本defer只能适用外部脚本文件 defer属性的用于是表明脚本在执行的时候不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后在运行。因此在&lt;\script&gt;元素中设置defer属性，想当于告诉浏览器立即下载，但延迟执行。 异步脚本HTML5为&lt;\script&gt;开始设置一个async属性，这个属性与defer属性相似，都用于改变处理脚本的行为。同样只是适用脚本文件。 defer与async的差异 123&lt;script src="myscript.js"&gt;&lt;/script&gt;&lt;script async src="myscript.js"&gt;&lt;/script&gt;&lt;script defer src="myscript.js"&gt;&lt;/script&gt; 下面是stackoverflow上的回答，可以参考一下： Without async or defer, browser will run your script immediately, before rendering the elements that’s below your script tag. With async (asynchronous), browser will continue to load the HTML page and render it while the browser load and execute the script at the same time. With defer, browser will run your script when the page finished parsing. (not necessary finishing downloading all image files. This is good.) 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。 高程中解释： 使用defer属性可以让脚本在文档中完全呈现之后再执行，延迟脚本总是按照指定他们的顺序执行。 使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照他们在页面中出现的顺序。 第三章 基本概念语法ECMAScript是明确区分大小写的 变量 虽然省略var操作符可以定义全局变量，但这也不是我们推荐的做法。因为在局部作用域中定义的全局变量很难维护，而且如果有意地省略var操作符，也会由于相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式下回导致抛出ReferenceError错误。 数据类型ES有5种基本数据类型:Undefined、Null、Boolean、Number和String，还有一种复杂数据类型Object。 对未初始化的变量执行typeof操作符会返回undefined值，而对未声明的变量执行typeof操作符同样也会返回undefined值。 操作符加性操作符如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来。 如果只有一个操作数是字符串，则将另一个操作数转换成字符串，然后再将两个字符串拼接起来。 相等操作符W3的说明： Operator Description == equal to === equal value andequal type ！= not equal ！== not equal value or not equal type]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript高程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解HTTP]]></title>
    <url>%2F2017%2F05%2F24%2FREADME%2F</url>
    <content type="text"><![CDATA[图解HTTP 点这里 第一章 第二章 第三章 第四章 第五章 第六章 第七章 第八章 第九章]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2017%2F05%2F24%2FAjax%2F</url>
    <content type="text"><![CDATA[Ajax教程 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 Ajax应用 运用XHTML+CSS来表达资讯； 运用JavaScript操作DOM（Document Object Model）来执行动态效果； 运用XML和XSLT操作资料; 运用XMLHttpRequest或新的Fetch API与网页服务器进行异步资料交换； 注意：AJAX与Flash、Silverlight和Java Applet等RIA技术是有区分的。 Ajax工作原理图列: Ajax创建对象 XMLHttpRequest是Ajax的基础 XMLHTTPRequest 对象XMLHTTPRequest用于在后台与服务器交换数据。这意味着可以再不重新加载整个网页情况下，对网页的某部分进行更新。 创建XMLHTTPRequest1variable = new XMLHTTPRequest(); 老版本的IE浏览器使用ActiveX对象 1variable = new ActiveXObject("Microsoft.XMLHTTP"); 为了应对所有浏览器，故采用下列写法 1234567891011var xmlhttp;if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest();&#125;else&#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");&#125; Ajax 向服务器发送请求 XMLHttPRequest对象用于和服务器交换数据 向服务器发送请求如需将强求发送服务器，我们使用XMLHttpRequest对象的open()和send()方法 12xmlhttp.open("GET","ajax_info.txt",true);xmlhttp.send(); 方法 描述 open（method,url,async) 规定请求的类型、URL以及是否异步处理请求 send(string) 将请求发送到服务器 !仅用于POST请求 GET和POST的区别与POST相比，GET更简单也更快 然而，在以下情况中，请使用POST请求 无法使用缓存文件（更新服务器的文件或数据） 向服务器发送大量数据（POST没有数据量限制） 发送包含未知字符的用户输入时，POST比GET更稳定也更可靠 GET请求一个简单的GET请求 12xmlhttp.open("GET","/try/ajax/demo_get.php",true);xmlhttp.send(); 可是上面的例子你可能得到的是缓存的结果，为了避免这种情况，向URL添加一个唯一的ID 例如： 12xmlhttp.open("GET","/try/ajax/demo_get.php?t="+Math.random(),true);xmlhttp.send(); Math.random()是数学随机数的意思 POST请求例子 12xmlhttp.open("POST","/try/ajax/demo_post.php",true);xmlhttp.send(); POST也可以像HTML表单那样POST数据，请使用setRequestHeader()来添加HTTP头。然后在send()方法中规定你希望发送的数据 实例： 123xmlhttp.open("POST","/try/ajax/demo_post2.php",true);xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");xmlhttp.send("fname=Henry&amp;lname=Ford"); way description setRequestHeader(header,value) 向请求添加HTTP头。- header：规定头的名称- value：规定头的值 url-服务器上的文件open()方法的url参数是服务器上文件的地址 1xmlhttp.open("GET","ajax_test.html",true); 异步 True或False？通过AJAX，JavaScript无需等待服务器的响应，而是： 在等待服务器响应时执行其他的脚本 当响应就绪后响应进行处理###Async=true 当使用async=true的时候，规定在响应处于onreadystatechange事件中的就绪状态时执行的函数 ###Async=false如果需要async=false，请将open()方法中的第三个参数改为false。 我们不推荐使用async=false，但对于一些小型的请求也是可以的。 请记住，JavaScript会等到服务器响应就绪才继续执行。如果服务器繁忙或者缓慢，应用程序会挂机或停止 Ajax-服务器 响应服务器响应如需获得来自服务器的响应，请使用XMLHttpRequest对象的responseText或responseXML属性。 属性 描述 responseText 获得字符串形式的响应数据 responseXML 获得XML形式的响应数据 responseText的实例响应不是XML 1document.getElementById("myDiv").innerHTML=xmlhttp.resposeText; 响应是XML，则采用respondText属性，实例 12345678xmlDoc=xmlhttp.responseXML;txt="";x=xmlDoc.getElementsByTagName("ARTIST");for (i=0;i&lt;x.length;i++)&#123; txt=txt + x[i].childNodes[0].nodeValue + "&lt;br&gt;";&#125;document.getElementById("myDiv").innerHTML=txt; Ajax - onreadystatechange事件当请求被发送到服务器时，我们需要执行一些基于响应的任务 每单readyState改变时，就会触发onreadystatechange事件. readyState 属性存在XMLHttpRequest的状态信息。 下面是XMLHttpRequest 对象的三个重要属性 属性 描述 onreadystatechange 存储函数（或函数名），每readyState属性改变时，就会调用该函数 readyState 存在XMLHttpRequest的状态，从0到4发生变化。0：请求未初始化1：服务器连接已建立 2：请求已接受 3：请求处理中 4：请求已完成，且响应已就绪 status 200：“OK” 404：没有找到页面 在onreadystatechange时间中，我们规定当服务器响应已做好被处理的准备时所执行的任务 当readyState等于4且状态为200时，表示响应已就绪。 具体例子 123456xmlhttp.onreadystatechange=function()&#123; if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200) &#123; document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125;&#125; 使用回调函数如果你的网站上有多个AJAX任务，那么你应该创建XMLHTTPRequest对象编写出一个标准的函数，并为每个AJAX任务调用该函数。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[resume]]></title>
    <url>%2F2017%2F05%2F24%2Fresume%2F</url>
    <content type="text"><![CDATA[简历的照片贴在md中。如果要看html文件或者pdf源文件​点击这，我的github]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>resume</tag>
        <tag>about</tag>
      </tags>
  </entry>
</search>