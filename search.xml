<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2017/12/6 note]]></title>
    <url>%2F2017%2F12%2F06%2F2017-12-6-note%2F</url>
    <content type="text"><![CDATA[近来的一些感想真的没觉得时间为什么过的这么快。还有好多事没去做，好多东西还没去学。今天考了网页设计，很简单。明天考C#，考完我的大学就只有剩下毕业设计了（实习我已经实习4个月）。 此刻，我正坐在延奎机房200号的座位上。恩，已经连续三天都坐这个位置上，没什么特别的理由，就是喜欢习惯坐同一位置上。 清晰的记得，我是从哪天开始渐渐明白我自己要去做什么。2016/9/16 正好是我的公立生日，当然那天也是中秋节放假，同时也是厦门台风登陆的后一天。那一天因为超强台风，寝室没电没水。我竟然发现，如果没电了，没电脑玩，我真的不知道自己能干什么。突然回想当初那么努力高考。虽然最后还是考的不咋样（人生一大耻辱）。现在也这么颓废。备注一下。就在上个学期，我甚至我辍学的想法，因为上个学期我真的发觉大学教的知识完全对我未来的工作没什么帮助。老师只是应付安排，我们只是为了学分，根本没人觉得以后会靠这个找工作。 还有上个学期，因为实在对学习不感兴趣，导致我挂了4科，又是人生一大耻辱，因为那时候我根本没心思。考过最好，没考过，我也打算辍学。很多因素导致我有这个想法。包括学校学习课程，宿舍环境。实话说。大学前2年我压根就是浪。慢慢忘记了未来，慢慢忘了初心。过着是一天过一天的生活。无聊就打打lol。 就因为那天，我才发现自己是多么没用，考试挂的那么多，而且没有什么求职技能。面对后面的毕业，肯定是害怕。 所以自从那天开始，我就常驻图书馆，没有9点不回去。自己慢慢开始自学编程，学java，学javascript，html，css，还有现在的python。 明天考完试这个学期也没什么事，接下来的计划就是安安心心地把vue，webpack等框架和工具学会。然后明年去杭州求职。实话实说，对厦门这座城市真的没有什么不舍，没什么怀念。也许毕业后，再也不会回来。 有时候看着其他人挺搞笑，就像看着曾经那个自己。 有时候觉得自己已经不错了，直到看到那些大神，才直到自己多么搞笑。 有时候觉得这件事挺容易，直到自己去做，才发现自己的无能。 有时候梦想着月入百万，直到自己拿到第一份工资，才发现梦想有多么遥远。 总是说未来还早，现在却就在眼前。 总是说生活不易，现在却迟迟未动。 总是说自己还年轻，同学早已当爹妈。 人生就这样，一直走，一直走，才发现到头，转头才发现，回去的路早就没了。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css样式优先级]]></title>
    <url>%2F2017%2F12%2F04%2Fcss%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[CSS样式导入与样式优先级 前言：再过几天就要网页设计考试了。虽然对我来说没什么大的难度。可是很久没看css样式一些知识点（会用是会用），趁着快考试，复习一下 CSS导入的方式 行内样式(内联样式) 在标签内直接编写行内样式 内部样式 在style标签内书写css 外部样式 HTML文件引用扩展名为.css的样式表，有两种方式 链接式 link标签 导入式 import导入 123&lt;style type=“text/css&gt; @import url("")&lt;/style&gt; 样式优先级行内样式&gt;内部样式&gt;外部样式（就近原则） 选择器的优先级 内联样式表的权值最高1000 id选择器权值为100 class类选择器权值为10 html标签选择权值为1 加起来谁大就继承谁 CSS优先级法则 当选择器都有一个权值，权值越大越优先 当权值相等时，后出现的样式表设置要优于先出现的样式表设置 继承的CSS样式不如后来指定的CSS样式 在同一组属性设置中标有”!important“规则的优先级最大]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prototype和和_proto_的关系是什么]]></title>
    <url>%2F2017%2F12%2F04%2Fprototype%E5%92%8C%E5%92%8C-proto-%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[prototype和_proto的关系 prototype 显式原型 _proto_ 隐式原型 prototype,每一个函数对象都有一个显式的prototype属性，它代表了对象的原型（Function.prototype函数对象是个例外，没有prototype属性）。_proto_:每个对象都有一个名为_proto_的内部隐藏属性，指向于它所对应的与原型对象。原型链正是基于_proto_才得以形成的 显式原型每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。 隐式原型JavaScript中任意对象都有一个内置属性[[prototype]],在ES5之前没有标准的方法来访问这个内置属性，但大多数浏览器都支持通过_proto_来访问。ES5中有了对于这个内置属性标准的Get方法: Object.getPrototypeOf() 二者的关系隐式原型指向创建这个对象的函数（constructor）的prototype 二者的作用 显式原型的作用 用来实现基于原型的继承与属性的共享 隐式原型的作用 构成原型链，同样用于实现基于原型的继承。举个例子，当我们访问obj这个对象中的x属性时，如果在obj中找不到，那么就会沿着_proto_依次查找。 构造函数的显示原型和隐式原型内建对象：比如数组 Array.prototype也是一个对象，对象就是由Object()这个构造函数来创建的。因此Array.prototype._proro_ == Object.prototype //true，或者可以这么理解，所有的内建函数都是由Object()创建而来的]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS RegExp 对象]]></title>
    <url>%2F2017%2F11%2F10%2FJS-RegExp-%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[什么是RegExpRegExp是正则表达式的缩写、 RegExp对象RegExp对象用于存储检索模式。 通过new 关键词来定义RegExp对象 方法Javascript RegExp对象有3个方法 test test()方法用来检测一个字符串是否匹配某个正则表达式，如果匹配成功，返回true,否则返回false exec exec()方法用来检索字符串中与正则表达式匹配的值。exec()方法返回一个数组，其中存放匹配的结果。如果未找到匹配的值，则返回null compile compile()方法可以再脚本执行过程中编译正则表达式，也可以改变已有表达式。 test()方法语法 RegExpObject.test(string) 例子 12//检测一个字符串是否以abc开头/^acv/i.test("abcdr") 12//检测一个字符串是否全是数字/^\d&#123;1,&#125;$/.test("12345678") exec()方法语法 RegExpObject.exec(string) compile()方法语法 RegExpObject.compile(regexp,modifier) regexp 正则表达式 modifier 规定匹配的类型 matchmatch方法可以在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 注意:match()方法将检索字符串String Object，以找到一个或多个regexp匹配的文本。属于字符串对象的方法而不是RegExp对象的方法。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[link的rel属属性解析]]></title>
    <url>%2F2017%2F11%2F01%2Flink%E7%9A%84rel%E5%B1%9E%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[link标签的rel作用解析 一般情况 stylesheet 调用外部样式表 1&lt;link rel="stylesheet" href="" type="text/css" media="screen" /&gt; 其中href是目标文档的URL，type则规定了目标URL的MIME类型，而media规定了文档将显示在什么设备上 meida： screen 显示器设备 print 打印设备 icon 定义网站收藏夹图标 12&lt;link rel="shortcut icon" href="http://blog.yunlives.com/images/favicon.ico" type="images/x-icon"/&gt;//IE &lt;link rel="icon" href="http://blog.yunlives.com/images/favicon.png" type="images/png"/&gt; icon属性指定标题栏，地址栏，收藏栏小图标 IE只支持ico格式的favicon；rel属性必须包含shortcut，才会才IE下显示 canonical 指明网址的规范版本 1&lt;link rel="canonical" href="/"/&gt; canonical属性用于让搜索引擎知道当前网站中的重复或相似网页中，哪一个页面才是站长想让其抓取与收录的。 author 申明文档作者 home 连接到站点的主页 search 连接到文档的搜索工具 sidebar 链接到应该在浏览器边栏显示的文档 friend 友情链接 link的预加载什么是预加载: 利用浏览器空闲的时间先去下载用户指定内容，然后缓存起来，这样用户下次加载时，就可以直接从缓存取出来，效率就高了 1&lt;link rel="prefetch" href="http://www.example.com/"&gt; &lt;!-- Firefox -&gt; 1&lt;link rel="prerender" href="http://www.example.com/"&gt; &lt;!-- Chrome -&gt; dns-prefetch dns-prefetch 分析这个页面需要的资源所在的域名，浏览器空闲时提前将这些域名转化IP，真正请求资源时就避免了上述这个过程的时间。 1&lt;link rel='dns-prefetch' href='/'&gt; 应用场景 我们的资源存在不同的CDN，那么提前声明好这些资源的域名，就可以节省请求发生时产生的域名解析的时间 如果我们知道用户接下来的操作一定会发起一起资源的请求，那就可以将这个资源进行dns-prefetch，加强用户体验。 rel=”subresource“表示当前页面必须加装的资源，必须放在页面最顶端先加载，有最高的优先级。 rel=”prefetch“表示当subresource所有资源都加载完开始预加载这里指定的资源，有最低的优先级。 注意:只有可缓存的资源才进行预加载，否则浪费资源 prerender(预渲染)rel=”prerender“表示浏览器会帮我们渲染可以隐藏指定的页面，一旦访问这个页面，就秒开了。 在Firefox中用rel=‘next’来声明 不是所有的资源都可以预渲染当资源位一下列表中的资源时，将阻止预渲染操作 URL中包含下载资源 页面中包含音频、视频 POST、PUT和DELETE操作的ajax请求 HTTP认证 HTTPS页面 含恶意软件的页面 弹窗页面 占用资源很多的页面 打开了 chrome developer tools 开发工具 preload浏览器必须请求preload标记的资源 1&lt;link rel="preload" &gt;]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域问题和jsonp]]></title>
    <url>%2F2017%2F09%2F19%2F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%92%8Cjsonp%2F</url>
    <content type="text"><![CDATA[跨域问题和jsonp了解浏览器跨域的相关知识和jsonp与json的不同 什么是跨域概念:只要协议、域名、端口有任何一个不同，都被当作是不同的域。 简单的说，只有当协议，域名，端口相同的时候才算是同一域名，否则认为需要做跨域的处理 跨域问题指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript施加的施加的安全政策。 主域名不同 跨域 子域名不同 跨域 端口不同 跨域 协议不同跨域 localhost 和 127.0.0.1虽然都是本机地址，也算跨域 为什么浏览器要限制跨域访问防止CSRF等攻击，防止恶意网站窃取数据，比如读取Cookie限制范围 Cookie、LocalStorage和IndexDB 无法读取 DOM 无法获得 AJAX请求不能发送 CSRF只是普及 什么是CSRF？ CSRF，中文名称:跨站请求伪造 CSRF可以什么做什么 可以这样理解，攻击者盗用你的身份，以你的名义发送恶意请求，个人隐私的泄露以及财产安全。 原理图 XSS攻击 什么是XSS XSS攻击全称跨站脚本攻击，是web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其他用户使用的页面中 跨域的解决方法 Jsonp CORS Server Proxy(服务器代理) location.hash 通过修改document.domian 跨域 使用window.name 进行跨域 使用HTML5的window.postMessage方法跨域 WebSocket CORS jsonp跨域 什么是Jsonp jsonp也叫做填充式JSON，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON 1callback(&#123;"name","trigkit4"&#125;) JSONP由两部分组成:回调函数和数据，回调函数式当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。 在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件是可以的，jsonp正是利用这个特性实现的 123456&lt;script&gt; function dosomething(jsondata)&#123; //处理获取的json数据 &#125;&lt;/script&gt;&lt;script src="http://example.com/data.php?callback=dosomething"&gt;&lt;/script&gt; js文件载入成功后执行我们在url参数后指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行配合相应的配合的。 123$callback = $_GET['callback'];//获得回调函数名$data = array('a','b','c');//要返回的数据echo $callback.'(''json_encode($data)')' jquery 封装jsonp 123$.getJSON('http://example.com/data.php?callback=?,function(jsondata)')&#123; //处理获得的JSON数据&#125; jquery的$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数 JSONP的缺点JSONP的缺点它只支持GET请求而不支持POST等其他HTTP请求。它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行javascript调用的问题 window.namewindow.name的不是一个普通的全局变量，而是当前窗口的名字，这里要注意的是每个iframe都有包裹它的window，而这个window是top window的子窗口，而它自然也有window.name 的属性，window.name属性的神奇之处在于name值在同的页面，加载依旧存在。并且可以支持非常长的name值(2M) postMessagepostMessage是HTML5新增的一项功能,跨文档消息传输。 document.domian对于主域相同而子域不同的情况下，可以通过设置document.domain的办法来解决。 Server Proxy服务器代理。当你需要有跨域的请求操作时发送请求给后端，让后端帮你代为请求，然后将获取的结果发送你 WebSocketWebSocket是一种通信协议，该协议不实行同源政策，只要服务器支持，就可以通过它进行跨域通信 CORS介绍CORS是跨域资源分享的缩写。它是W3C标准，是跨源AJAX请求根本方法，相比JSONP只能发送GET请求，CORS允许任何类型的请求 原理它允许浏览器像跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源的使用的限制。 简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程中，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，又是还会多出一次附加的请求。 因此，实现CORS通信的关键是服务器。只有服务器实现了CORS接口，就可以跨源通信。]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript阻止气泡]]></title>
    <url>%2F2017%2F09%2F08%2FJavaScript%E9%98%BB%E6%AD%A2%E6%B0%94%E6%B3%A1%2F</url>
    <content type="text"><![CDATA[主要分析一下return false和stopPropagetion的区别 event.stopPropagetion 抄录 w3 定义和用法 不在派发事件，终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播，调用该方法后，该节点上处理该事件的处理程序将被调用，事件不再被分派到其他节点。 语法 12&gt; event.stopPropagation()&gt; &gt; 说明 该方法就停止事件的传播，阻止它被分派到其他Document节点。在事件传播的任何阶段都可以调用它的。注意，虽然该方法不能阻止同一个Document节点上的其他事件句柄被调用，但是他可以阻止把事件分派到其他节点。 return false先回顾一下事件冒泡知识。 大部分事件都是现在初始DOM触发，然后再通过DOM树往上，在每一级父元素上触发。事件不会再兄弟节点或者子节点上冒泡(当事件向下冒泡时，我们叫事件捕获)。 每次调用return false 的时候，实际上做了三件事件: event.preventDefault(); event.stopPropagation(); 停止回调函数执行并立即返回。 三件事件中用来阻止浏览器继续执行默认行为只有preventDefault，**除非你想要停止事件冒泡，否则使用return false 会为代码埋下很大隐患。 具体比较 event.stopPropagation() 这个阻止事件的冒泡方法，不让事件向Document上蔓延，但是默认事件仍然会只想，例如当你调用这个方法的时候，如果点击一个链接，这个链接仍然会被打开。 event.preventDefault() 这是阻止默认事件的方法，调用这个方法，链接不会被打开。但是会发生冒泡，冒泡会传递到上一层的父元素。 return false 会同时阻止事件冒泡也会阻止默认事件。、 网上的一些例子 123&lt;div class = "box1"&gt; &lt;a href = "www.baidu.com"&gt;&lt;/a&gt;&lt;/div&gt; js代码: 1234//不阻止事件冒泡和默认事件$('.box1').click(function()&#123; console.log("1")//不阻止事件冒泡会打印，页面跳转&#125;) 1234567//阻止冒泡$('.box a').click(function(event)&#123; event.stopPropagation();//不会打印1，但是页面会跳转&#125;);$('.box').click(function()&#123; console.log("1");&#125;) 1234567$('.box a').click(function(event)&#123;//阻止默认事件 event.preventDefault();//页面不会跳转，但是会打印出1&#125;)；$('.box').click(function()&#123; console.log("1");&#125;) 12345678910$('.box1').click(function()&#123; console.log("1")&#125;);//阻止冒泡$('.bix1 a').click(function(event)&#123; event.stopPropagation(); //阻止默认事件 event.preventDefault();//页面不会跳转，也不会打印出1 //等同于 return false&#125;)]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript!==和!=]]></title>
    <url>%2F2017%2F09%2F06%2FJavaScript!%3D%E5%92%8C!%3D%3D%2F</url>
    <content type="text"><![CDATA[!== 与 != 的区别这次笔记主要是理清JavaScript中的 != 和 !==的区别在JavaScript中“===”叫做严格运算符，而“==”叫做相等运算符。 严格运算符的运算规格如下(抄录知乎某兄弟) 不同类型值 如果两个值得类型不同，直接返回false。 同一类的原始类型值 同一类型的原始类型的值(数值、字符串、布尔值)比较值，如果值相同就返回true，值不同就返回false。 同一类的复合类型值(重点) 两个复合类型(对象、数组、函数)的数据比较时，不是比较他们的植是否相等，而是比较它们是否指向同一对象。 undefined和null nuderfined 和 null与自身严格相等 1234null === null //=&gt;trueundefined === undefined // =&gt;truenull === undefined // =&gt;false null == undefined //=&gt;true 相等运算符在比较相同类型的数据时，与严格相等运算符一样。 在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符进行比较 原始类型的值 原始类型的数据会转换数值类型再进行比较。字符串和布尔值都会转换成数值 对高级的类型，比如函数，对象，数组，===与==没有区别。 最后总结，最好用严格运算符。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[载流函数的使用]]></title>
    <url>%2F2017%2F08%2F21%2F%E8%BD%BD%E6%B5%81%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[JavaScript节流函数(载流函数)Throttle解析自己项目中一般载流函数的写法。 1234567//截流函数 self.throttle = function (method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function () &#123; method.call(context); &#125;, 400); &#125;; 载流函数的作用在浏览器DOM事件中，有一些事件会随着用户的操作不间断的触发。 有时候如果事件处理方法比较庞大，DOM操作比较复杂，还不断的促发此类事件就会造成性能上的损失，导致用户体验较低(UI反应慢，浏览器卡死)，所以通常我们会给相应事件添加延迟执行的逻辑。 网上copy的代码1234567var timer = null;window.onresize = function () &#123; clearTimeout(timer); timer = setTimeout(function() &#123; testFn(); &#125;, 100);&#125;; 感觉跟我项目用的差不多(我的书写主要是照着前一位学长写的) 产生的问题如果js代码中还有别的功能也叫timer就产生冲突，可以采用闭包来解决 123456789101112131415var throttle = function (fn, delay) &#123; var timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(function() &#123; fn(); &#125;, delay); &#125;&#125;;var f = throttle(testFn, 200);window.onresize = function () &#123; f();&#125;;]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度2017春招笔试编程题]]></title>
    <url>%2F2017%2F06%2F25%2F%E7%99%BE%E5%BA%A62017%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一题度度熊想去商场买一顶帽子，商场里有N顶帽子，有些帽子的价格可能相同。度度熊想买一顶价格第三便宜的帽子，问第三便宜的帽子价格是多少？ 输入描述:首先输入一个正整数N（N &lt;= 50），接下来输入N个数表示每顶帽子的价格（价格均是正整数，且小于等于1000） 输出描述:如果存在第三便宜的帽子，请输出这个价格是多少，否则输出-1 输入例子:1010 10 10 10 20 20 30 30 40 40 输出例子:30 python: 123456789101112131415161718192021#coding=utf-8'''Created on 2017/6/21@author: Administrator'''n=input("")price=raw_input("")price=price.split()price=map(eval, price)price=sorted(price)a=[]a.append(price[0])for i in range(1,n): b=price[i] c=price[i-1] if b&gt;c: a.append(b)if a.__len__()&lt;3: print(-1)else: print a[2] 第二题一个数轴上共有N个点，第一个点的坐标是度度熊现在位置，第N-1个点是度度熊的家。现在他需要依次的从0号坐标走到N-1号坐标。但是除了0号坐标和N-1号坐标，他可以在其余的N-2个坐标中选出一个点，并直接将这个点忽略掉，问度度熊回家至少走多少距离？输入描述:输入一个正整数N, N &lt;= 50。 接下来N个整数表示坐标，正数表示X轴的正方向，负数表示X轴的负方向。绝对值小于等于100 输出描述:输出一个整数表示度度熊最少需要走的距离。 输入例子:41 4 -1 3 输出例子:4 python： 1234567891011121314151617#coding=utf-8import mathn=input('')sum1=raw_input('')sum1=sum1.split()sum1=map(eval, sum1)he=0cha=[]for i in range(1,n): he=he+abs(sum1[i]-sum1[i-1]) for i in range(1,n-1): cha1=abs(sum1[i]-sum1[i-1])+abs(sum1[i+1]-sum1[i])-abs(sum1[i+1]-sum1[i-1]) cha.append(cha1)b=max(cha)c=he-bprint c]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>baidu</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习指南]]></title>
    <url>%2F2017%2F06%2F24%2FGit%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[看了一本《Git学习指南》的书，所以写了这个note，多多学习Git操作，也好装B，以前只会简单几个操作。 基本概念分布式版本控制、有何过人之处集中式概念： 是将项目集中存放在中央服务器中，在工作的时候，大家只在自己电脑上操作，从同一个地方下载最新版本，然后开始工作，做完的工作再提交给中央服务器保存。这种方式需要联网，现在云开发就是这样的处理方式。 分布式概念： 只要提供一台电脑作为版本集中存的服务器放就够了，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它也一样干活，只是交换修改不方便而已。而每一台电脑有各自独立的开发环境，不需要联网，本地直接运行，相对集中式安全系数高很多。 以上的简介和图片均来自网上blog 分布式版本控制的特型版本库 项目版本库：该版本库主要用于存储有“官方”创建并发行的版本 共享版本库：该版本库主要用于开发团队内人员之间的文本交换。 工作流版本库：工作流版本库通常只用于填充那些代表工作流中某些特定进展状态的修改，例如审核通过后的状态等 派生版本库：该版本库主要用于从开发主线分离出某部分内容（例如，分离出那些开发耗时较长，不适合在一个普通发布周期内完成的内容），或者隔离出永远不会被包含在主线中的、用于实验的那部分开发进展。 分布式系统的优点 高性能：几乎所有的操作都不需要进行网络访问，均可直接在本地执行 高效的工作方式：开发者可通过多个本地分支在不同任务之间进行快速切换 灵活的开发进程：我们可以在团队和公司中为其他部门建立专门的版本库，例如为方便与测试人员交流而建的版本库。这样相关修改就会很容易发布，因为只是特定版本库上的一次推送。 备份作用：由于每个开发者都持有一份拥有完整历史版本的版本库副本，所以因服务器故障而导致数据丢失的可能性是微乎其微。 可维护性：对于那些难以对付的重构工作，我们可以在将成功传送给其原始版本库之前，先在该版本库的副本尝试一下。 版本库，分布式工作的基础所在版本库其实就是一个高效的数据存储结构而已，由以下部分组成 文件 目录 版本 对于所有数据，它们会被计算一个十六进制散列值。这个散列值将会被用作相关对象的引用，以及日后恢复数据时所需的键值。 也就是说，一个提交对象的散列值实际上就是它的版本号，如果我们持有某一提交的散列值，就可以用它来检查对应版本是否存在于某一版本库中。如果存在，我们就可以将其恢复到当前工作区相应的目录中。如果该版本不存在，我们也可以从其他版本库中单独导入该提交所引用的全部对象。 散列值和版本库的优点 高性能：通过散列来访问数据时非常快的 冗余度—释放存储空间：相同的文件内容只需存储一次即可 分布式版本号：由于相关散列值是根据文件，作者和日期来计算的，所以版本也可以“离线”产生，不用担心将来会因此而发生版本冲突。 版本库间高效同步：当我们将某一提交从一个版本库传递给另一个版本库，只需要传递那些目标版本库中不存在的对象即可。而正是因为有了散列值的帮助，我们才能很快判断相关对象是否已经存在。 数据完整性：由于散列值是根据数据的内容来计算的，所以我们可以随时通过Git来查看某一散列值是否与相关数据匹配。以检查该数据上可能的意外变化或恶意操作 自动重命名检测：被重命名的文件可以被自动检测到，因为根据该文件内容计算出的散列值并没有发生变化。也正因为如此，Git中并没有专门的重命名命令，只需移动命令即可。 入门准备Git环境去官网安装 去Git官网安装 config命令配置用户名和用户邮箱 git config –global user.email “xxxxx@xxx.com” 第一个Git项目创建版本库init命令，对于一个带版本库的项目目录，通常称之为工作区 git init 首次提交第一步，我们先要用add命令来确定哪些文件应被包含下次提交中。第二步，再用commit命令将修改传送到版本库中，并赋予该提交一个散列值以便标识这次新提交。 git add xx.text git commit –message “xxx” 检查状态 git status status命令就会显示出该项目自上次提交以来所发生的所有修改。 git diff 命令可以显示其每个被修改的行 提交修改接下来，所有修改都必须要被先归档成一次新的提交。我们要对修改过的文件和新文件执行add命令，并对要删除的文件使用rm命令。 git add foo.txt bar.html git rm bar.txt 现在再次调用status命令，我们会看到所有的修改已经被纳入下次提交中。 然后在用commit命令提交这些修改。 显示历史log 命令可用来显示项的历史，所有提交都会按时间顺序被降序排列出来 git log Git 的协作功能克隆版本库 git clone git pull命令可以从原版本库中取回新的修改，将它们与克隆体中的的本地修改进行对比，并在工作区中合并两边的修改，创建一次新的提交。这个过程就是所谓的合并。 创建共享版本库除了可以用pull命令从其他版本库取回相关提交外，我们也可以用push命令将提交传送给其他版本库。 Pull命令：取回修改推送和拉回push和pull命令可用于在本地和远程版本库之间共享版本提交。 提交究竟是什么提交的时候不仅提交被修的文件，它包含该项目的所有文件,针对每次提交，Git都会为其计算一个由40个字符组成的唯一编码,我们称之为提交散列值。只要知道这个散列值，我们就可以将项目中的文件从版本库中恢复到该提交被创建的那个时间点上。在Git中，恢复到某一版本通常被称之为检出(checked)操作。 add命令与commit命令我们可以分add命令和commit命令着两步来创建一次提交 注册修改 我们可以用add命令来进行注册，将所有的修改纳入下次提交。在这里，你可以使用-all参数，这表示我们会将所有修改都纳入在内 git add –all 创建提交 现在可以创建一次新的提交 git commit 在谈提交散列值Git选择散列值的理由 这样的提交散列值可以在本地生成。我们无需与其他计算机或中央服务器进行通信，就可以随时随地创建新的提交。 提交散列值中的信息要比单纯一个软件版本的名称要多得多。 提交历史版本库中所包含的并不仅仅是一个个独立的提交，它同时也存储了这些提交之间的关系。没当我们修改了软件并确认提交时，Git就会记下这个提交之前的版本， 提交之间的差异的比较通过diff命令，我们可以比较出两次提交之间的差异。 同一项目的多部不同历史我们可以通过log命令来显示提交历史 部分输出：-n该选项通常用于限制输出，例如显示最后三次提交 git log -n 3 格式化输出：–format、–oneline对于日志的输出格式，我们可以用–format选项来控制。–oneline选项所显示的概述信息 统计修改信息：–stat、–shortstat统计类选项也是很有用的：–stat可用来显示被修改的那些文件。–dirstat则可以用来显示那些包含被修改文件的目录。而–shortstat则用来显示项目中有多少文件被修改，以及新增或删除了多少文件 日志选项：–graph我们也可以通过–graph选项来显示各提交之间的关系 多次提交提交的产生通常分为两个步骤。首先，我们要用add命令将所有相关的修改纳入到一个缓存区中。这个缓存区通常被叫做暂存区或索引。接着我们才能用commit命令将暂存区中的修改传送到版本库中。 status命令通过status命令，我们可以查看到当前工作区中所发生的修改。以及其中的哪些修改已经被注册到了暂存区中，以作为下次提交的内容。 changes to be committed:被提交的修改，这部分将列出那些将在下次提交中被纳入版本库中的、被修改的文件。 changed but not updated:不会被更新的修改，这部分将列出那些已被修改，但尚未被注册到下次提交中的文件 untracked files:未被跟踪的文件，这部分将列出所有的新增文件 怎样的修改不该被提交 为调试而做的实验性修改 意外添加的修改 尚未准备好的修改 自动生成文件中所发生的修改 从暂存区撤回修改reset命令可用来重置暂存区。其中第一个参数为HEAD，表示的是我们将其重置为当前HEAD版本。第二个参数则用来指定要被重置的文件或目录 用.gitignore忽略非版本控制文件创建一个名为.gitignore文件，文件内的文件就会被忽略 存储情况：如果我们在某些事情进行到中间的时候，突然发现自己需要快速修复某个问题。这个时候，我们通常会希望立即去做相关的修改，但同时先不提交之前一直在做的事情。在这个情况下，我们可以用stash命令先将这些修改保存在本地，日后再处理。 我们通过stash命令将工作区和暂存区中的修改保存在一个被我们称之为储藏栈的缓存区中 我们可以用stash pop命令将栈中所储藏的修改恢复到工作区中 版本库 对象数据库：所有提交中的文件、目录以及相关的元数据将被存储在该数据库 SHA1散列值：我们可以通过一个SHA1散列值从对象数据库中捡取相关对象。SHA1散列值是一种针对文件内容的加密校验植 相同数据只存储一次：内容相同的对象拥有相同的SHA1散列值，并且只存储一次 相同的数据会被压缩：对于内容相似的数据，Git会针对其被修改的部分采取增量存储的方法 Blob对象：文件的内容将会被存储在相应的blob对象中 Tree对象：目录会被存储在相应tree对象中。一个tree对象中通常会包含一份文件名列表，包含这些文件名和存储在blob或tree对象中内容的SHA1散列值 重命名检测：文件的重命名和移动操作在提交之前无需报备。Git可以自动根据文件内容的相似度来识别操作 2017/9/16 最近有点忙，今天周末抽空把这本书看看完，写完笔记就换回去。 分支 当有多个开发者用git处理同一软件开发项目时，他们就会在版本库的提交图中创建各自的分支， 在一个Git版本库中，总是唯一存在着一个活动分支，我们可以用branch命令来列出当前所有的分支。其中用*凸显的就是当前活跃分支。 一般情况下，活动分支将会被继续用于接受所有新的提交，并将分支指针移动至最近的那次提交。当然，我们也可以用checkout命令来改变当前的活跃分支 创建一个分支 git branch xx 切换到新分支 branch命令只能用于创建新的分支，但并不会自动切换到该新的分支 git checkout a-branch 快捷方式: 创建并切换到新的分支 git checkout -b a-branch 重置分支指针分支指针主要用于指向活动分支，它每次提交时移动到最新提交上，因此在通常情况下，我们几乎不太需要去直接设置分支指针，但偶尔我们也会因为一些偶发事件而失去该指针的跟踪，想将其恢复到之前的状态，在这种情况下，我们可以用reset命令来重置分支指针 git reset –hard 39ea21 这样一来，该指针就被重置到提交39ea21所在活动分支上了。其中–hard选项用于确保工作区和缓存区也都会被设置都提交39ea21的状态 reset –hard 命令会覆盖当前工作区和暂存区中的所有修改。所以最好在执行重置之前先用git stash 命令来存储一下这些修改 git stash 可以将修改储存起来，然后再进行切换。之后用stash pop 命令来恢复它们 删除分支 git branch -d b-branch 恢复被删除的分支Git会自行负责分支的管理，所以当我们删除一个分支时，Git只会删除了指向相关提交的指针，但该提交对象依然会留在版本库中。因此，如果我们知道删除分支时的散列信息，就可以将某个已删除的分支恢复过来 合并分支使用merge命令来进行分支合并是Git的重要操作之一。我们可以通过指定分支名称来选择待合并修改的分支，然后Git会基于合并的内容来创建一次新的提交。 冲突Git 非常适合于几个开发者对同一软件做多处修改时，被用于合并他们对程序源代码中所做的修改。这些操作甚至常会涉及那些受移动或重命名操作影响的文件 编辑冲突 通常发生在两个开发者对同一行代码做了不同修改的时候，在这种情况下Git往往无法自行确定两种修改中的哪一种才是正确的。 内容冲突 通常发生在两个开发者对某份代码的几个部分作出各自修改的时候。例如这种情况下就容易导致这类冲突：当一个开发者在修改某一函数的时候，另一个开发者也在同一时间修改同一函数 pull 和 push 写访问: push 只能用在我们对其他版本库有写访问权限时。 只针对快进合并: push操作通常不会带来合并(不像pull命令)push操作只在快进提交模式下被允许，也就是远程版本没有比本地更多更新的提交 无远程跟踪分支 无参数调用push : 在无参数的情况下，push命令将只发送那些在其他版本库中有相同名字匹配的本地分支。与之不同的是，pull 和 fetch 所选取的都是全部分支。 总结pull = fetch + merge pull命令是两种操作的组合。它首先执行的是获取操作。 常用技巧忽略临时性的本地提交 gitignore 文件中的那些条目在这里可起不了作用，因此它们只针对那些不受Git管理的文件 检查对文本文件的修改一般情况下，Git的diff算法会去逐行比较两个文件。因为在源代码中，我们往往修改的都是单行内容，其邻近、行通常不会被涉及，所以diff算法很容易就能察觉到其中的不同。但在文本文件中，事情就不一样了。因为其修改往往是整体性的，例如我们可能会将某些单词整体从一行移动另一行。所以从diff的输出中，我们往往很难看出一个文本文件究竟修改那些内容 对于连续性的文本，–word-diff选项会很用,它可以按单词显示我们所做的修改 git diff –word-diff –word-diff=color 不同颜色显示 别名 git config –global alias.ci commit 上面就将commit命令简写为ci 项目设置工作流简介基于项目目录创建一个新的版本库 准备空目录 忽略不需要的文件和目录 创建一个版本库 定义行尾终止符 导入终止符 创建一个裸版本库]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础知识]]></title>
    <url>%2F2017%2F06%2F18%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[记录一下:因为上上个学期不好好学习，导致我的信息技术考试考了55分，结果今年又要重修，所以在距离考试还有5天的时间，我得认真复习，因为以后可能就走这个行业，所以还是做好笔记认认真真复习一遍。 TCP/IP介绍简介TCP/IP 中译名为传输控制协议/因特网互联协议，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准，是一组协议族。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台电脑规定一个地址。 OSI模型中，应用层、传输层和数据链路层保证了数据的可靠性。 OSI模型 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 TCP/IP模型 应用层 传输层 网际层 网络接口层 数据封装过程例如发送一封电子邮件 应用层将数据编码成电子邮件并发送给传输层 传输层将信息分段，并在其头部添加控制信息（保证分段在目的地按顺序重组），构成数据段，发送给网际层。 网际层在数据段的IP头部添加IP地址信息，构成数据包，发送给网络接口层 网络接口层在数据包的头部添加MAC地址，构成帧。帧的尾部添加差错检查信息（FCS） 物理层将帧编码成能在介质上传输到目的地的比特流 CISCO设备交换机：二层交换机工作在OSI的数据链路层 ​ 三层交换机同事工作在OSI的数据链路层和网络层 网关：从表面来看工作在三层，实际上网关是一个杂合物，属于所有层都有，七层。 网桥：数据链路层 路由器：网络层 交换机和路由器的区别： 交换机工作在第二层，路由器工作在第三层 交换机使用MAC地址寻址（物理地址），路由器使用IP地址寻址（逻辑地址） 交换机的主要作用将PC连接在一起，而路由器主要作用是路由选择和分割广播域 OSI模型各层介绍物理层物理层功能是利用物理传输介质为数据链路层提供物理连接，以便透明的传输比特流，简单说就是设置网络拓扑结构、比特传输、位同步。 数据表现形式：比特流，这样的叫法叫PDU(协议数据单元) 介质三种介质：铜缆，光纤，无线介质 铜介质：粗缆、细缆、双绞线 拓扑结构物理拓扑：是根据网络设备的实际物理地址进行扫描而得到 类型：bus(总线型)，ring(环状拓扑)，star(星型拓扑)，tree(树型拓扑)，net(网状拓扑) 逻辑拓扑：是以网络设备的IP地址划分为依据生成的拓扑图 类型：广播broadcast，令牌传递/令牌环token-passing 主要设备中继器、集线器 数据链路层数据链路层功能在此层将数据分帧，并处理流控。屏蔽物理层，为网络层提供一个数据链路的链接，在一条有可能出差错的物理连接上，进行几乎无差错的数据传输。本层指定拓扑结果并提供硬件寻址 简单地说就是：成帧、物理寻址、流量、差错控制 数据表示形式：帧 主要设备交换机 交换模式 直通式（Cut Through）：当输入端口检测到一个数据包时，就检查该包的爆头，根据包内的目的地地址把数据包直通到相应的端口。 存储转发式（Store and Forward）：这种方法先将数据包完整的接收下路，经过CRC检查，如果数据包没有错误，在根据地址进行转发。 无碎片转发（Fragment Free）：它检查数据包的长度是否够64字节，若小于64字节，说明是弃包，进行丢弃，若大于64字节，则发送该报 MAC地址(考试重点)表示：6个字节，48个二进制位 MAC地址与Ipv6的联系： MAC地址生成64位主机地址规则： 从左边数第一份倒数第二个字节取反，与第二个字节合写 第三个字节后加ff 第四个字节前面加上fe 第五个和第六个字节合写 例：00-13-D3-02-F7-30 → 0213-D3ff-fe02-F730 注释MAC地址是硬件地址（物理地址），作用在数据链路层，而IP地址是软件地址（逻辑地址），作用在网络层 ARP(地址解析协议)功能：将IP地址解析为对应的MAC地址 考题：两台主机无法通信的原因（ARP角度） 解答：当发送接收双方主机在一个网段时，当一个主机向另一台主机发送通讯时，认为两者在同一网段，这时会进行不断请求，而消息将会发送到错误的目的地，导致无法通讯，解决方法是使用代理ARP。 RARP(逆向地址解析协议)(反向ARP协议) 功能:将MAC地址解析为对应的IP得知 以太网组成：物理层+部分数据链路层，即OSI模型1,2层 网络层网络层功能本层通过寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。它包括通过互联网络开路由和中继数据。 简单来说就是：逻辑寻址，路由选择 数据表示形式：数据包 IP地址 构成：IP地址=网络地址位+主机地址位 作用：识别与定位 分类 A类：0.0.0.0-127.255.255.255 8位网咯地址+24位主机地址 B类：128.0.0.0-191.255.255.255 16位网络地址+16位主机地址 C类：192.0.0.0-223.255.255.255 24位网络地址+8位主机地址 D类：224.0.0.0-239.255.255.255 组播地址 E类： 240.0.0.0-255.255.255.255(其中255.255.255.255为全网广播地址)，E类地址一般用于研究作用 广播地址和网络地址 广播地址：主机位全为1，网络地址：主机位全为0 子网掩码： 定义：网络地址位全为1+主机地址全为0 网络地址=IP地址&amp;子网掩码 表示： /n n为网络地址位长度 /8→255.0.0.0 /9→255.128.0.0 作用：分割子网，将IP地址与子网掩码做与操作，将相同的合并在同一个子网中 IPV6 长度：128位，64位网络地址+64为主机地址 主要设备路由器 传输层传输层功能常规数据递送，两种递送方式：面向连接（TCP）或无连接（UDP）。为会话层用户提供一个端到端的可靠、透明盒优化的数据传输服务机制。包括全双工或半双工、流控制和错误恢复服务。 简单的说就是：端口寻址、分段重组、流量、差错控制 数据表示形式：数据段 两个协议：TCP和UDP TCP：当发送方发送数据段时，发送方需要TCP协议与接收方连接建立会话，采用三次握手的方式，连接后即可建立虚数据进行发送数据通信，使用TCP协议连接时都要建立三次握手原则。 UDP：当发送方发送数据段时，不需要和接收方进行协商联系，也不给数据段标号，直接发送过去，并不关心数据段是否到达接收方 使用TCP协议规则的协议有：FTP HTTP SMTP Telent DNS 使用UDP协议规则的协议有： TFTP SNMP DHCP DNS TCP和UDP优缺点 TCP UDP TCP协议面向连接 UDP协议面向非连接 TCP协议传输速度慢 UDP协议传输速度快 TCP协议采用字节流方式，如果字节流太长，将其分段，保证数据顺序，不出现丢失或乱序 UDP协议不保证，尽最大能力交付 TCP协议对系统资源要求多 UDP协议要求少 TCP协议保证数据正确性，超时重发，丢弃重复数据，有可靠性 UDP协议可能丢包 TCP协议提供端到端、全双工通信 UDP协议是广播式的 三次握手原理（考试重点）TCP是因特网中的传输层协议，使用三从握手协议建立连接，这种建立连接的方法可以防止产生错误的连接。 字段含义： ACK 确认字段 SYN 同步序列号 过程 第一次握手：建立连接时，客户端发送syn数据段到服务器，并等待服务器确认。 第二次握手：服务器收到syn数据段，从而建立于客户端的会话，为了确认收到客户的SYN包，同时自己也发送一个SYN数据段，即SYN+ACK， 第三次握手：客户端收到服务器的SYN+ACK数据段，向服务器发送包含ACK数据段，此数据段发送完毕后，客户端和服务器进入TCP连接成功状态，完成三次握手。 会话： 两种状态：创建会话(采用三次握手)，终止(发送FIN消息) 应用层会话层功能 在两个节点之间建立端连接，为端系统的应用程序之间提供了对话控制机制。此服务包括建立连接时以全双工还是以半双工的方式进行设置。 简单地说就是：对话控制，建立同步 表示层功能主要用于处理两个通信系统中交换信息的表示方式。为上层用户解决用户信息的语法问题。它包括数据格式交换、数据加密与解密、数据压缩与恢复等 简单地说就是：翻译、加密、压缩 应用层功能为特定类型的网络应用提供了访问OSI环境的手段。应用层确定进程之间通信的性质，以满足用户的需要。应用层不仅要提供应用程序所需要的信息交换和远程操作，而且还要作为应用进程的用户代理，来完成一些为进行信息交换所必需的功能。它包括：文件传送访问和管理FTAM，虚拟终端VT、事物处理TP、远程数据库访问RDA、制造业报文规范MMS、目录服务DS等协议 简单地说就是文件传输、电子邮件、文件服务、虚拟终端‘ 三层的数据表现形式：一般称为消息 TCP/IP模型应用层协议这个就不详细讲了 TCP/IP模型应用层协议端口 协议 端口 采用协议 文件传输协议(FTP)数据 20 TCP 文件传输系诶(FTP)控制 21 TCP Talnet(远程登录) 23 TCP 简单邮件传输协议(SMTP) 25 TCP 简单文件传输协议(TFTP) 69 UDP 超文本传输协议(HTTP) 80 TCP 域名系统(DNS) 53 TCP/UDP 邮局协议(POP3) 110 TCP 安全的HTTP(HTTPS) 443 TCP 思科考试重点：填空题： 在以太网中，ip的作用是识别和定位。 TCP通过使用流量控制和滑动窗口来提供阻塞控制 对于在不同网段的两台主机，在数据的传输过程中，从源主机发送后，到目的主机接收前，数据所经过的OSI模型的最高层是网络层 ipconfig 查找网关IP地址，tracert追踪用于返回数据包在网络中传输时，沿途经过的跳列表，即追踪从源主机到目的主机所经过的路由器地址，nslookup 手动查询域名服务器指令 各层的协议 应用层： DNS HTTP SMTP(简单邮件传输协议) POP POP3 Telent DHCP(动态主机配置协议) FTP 网际层协议 ARP RARP ICMP 传输层协议 TCP UDP ping不通目的主机各层可能发生的错误 物理层故障：线缆短路，接口故障，速率、双工状态不一致 数据链路层：数据帧的封装格式不同 网路层：没有安装相应协议，没有设置正确IP地址。 网页无法连接各层可能发生的错误 物理层故障：网线松动，接口故障 数据链路层：设备配置错误，设备没有安装驱动程序，例如网卡驱动 网络层：IP地址是否配置正确，子网掩码是否正确，网关是否正确，DNS或DHCO设置是否正确 传输层：防火墙设置错误，应用程序的TCP或UDP端口是否被打开 会话层、表示层、应用层：应用软件故障。 题目：请以OSI七层模型为例，说明在网络通信过程中，如何保证数据的可靠性 传输层 ：滑动窗口，序列号，确认 数据链路层 ：帧检测序列FCS 应用层：校验文件类型 题目：210.34.160.0/24网段分成两个字网，由于客户端(client)子网掩码设置错误,都设成255.255.255.0，造成两个子网不能正常通信，请解释 子网掩码的作用 定义地址的网络和主机部分，子网划分 不能通信的原因（从ARP的角度） 当发送接收双方主机在一个网段时，当一个主机向另一台主机发送通讯时，认为两者在同一网段，这时会进行不断请求，而消息将会发送到错误的目的地，导致无法通讯 题目：请解释数据到传输层后，物理层前，这些层对数据封装 传输层分割数据，成段 网络层：加上相应的IP报头 数据链路层加上报尾形成帧 题目·数据在各个阶段的PDU 物理层：比特流 bit 数据链路层：帧frame 网络层：数据包packet 传输层：数据段segment]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3实战笔记]]></title>
    <url>%2F2017%2F06%2F10%2FCSS3%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3]]></title>
    <url>%2F2017%2F06%2F08%2FCSS3%2F</url>
    <content type="text"><![CDATA[CSS3初步认识CSS3简介CSS3模块一些重要的CSS3模块 选择器 盒模型 背景和边框 文字特效 2D/3D转换 动画 多列布局 用户界面 CSS3边框CSS3圆角在CSS3中border-radius属性被创建圆角 CSS3盒阴影在CSS3中添加box-shadow属性 实例 123div&#123; box-shadow: 10px 10px 5px #888888;&#125; CSS3边界图片你可以使用图像创建一个边框 CSS3 圆角CSS3 border-radius -指定每个圆角CSS33背景CSS3背景属性： background-image background-size background-origin background-clip CSS3 background-image属性CSS3中可以通过background-image属性添加背景图片。 不同的背景图像用逗号隔开，所有图片中显示在最顶端(最顶层)的为第一张。 实例： 12345#example&#123; background-image: url(img_flwr.gif),url(paper.gif); background-position: right bottom,left top; backgrond-repeat: no-repeat, repeat;&#125; CSS3 background-size属性background-size指定背景图像的大小 你也可以指定像素或百分比大小，指定的大小是相对于父元素的宽度和高度的百分比的大小 CSS3 background-Origin属性background-Origin属性指定了背景图像的位置区域 content-box，padding-box和border-box区域内可以放置背景图片 CSS3 background-clip属性 CSS3中background-clip背景剪裁属性是从指定位置开始绘制的 content-box，padding-box和border-box三个可选参数 CSS3渐变CSS3定义了两种类型的渐变 线性渐变-向下/向上/向左/向右/对角方向 径向渐变-由它们的中心定义 使用透明度CSS3渐变也支持透明度，可以创建减弱变淡的效果。 CSS3文本效果 text-shadow box-shadow text-overflow（文本溢出） word-wrap(单词换行) word-break（文本拆分换行） CSS3字体使用你需要的字体在新的@font-face规则中，你必须首先定义字体的名称，然后指向该字体文件。 如需为HTML元素使用字体，请通过font-family属性来引用字体的名称 123456789&lt;style&gt;@font-face&#123; font-family: myFirstFont; src: url(sansation_light.woff);&#125;div&#123; font-family: myFirstFont;&#125;&lt;/style&gt; CSS3 2D转换 translate()移动 rotate()旋转 scale()元素的增减 skew()坐标轴的倾斜角度 matrix()包含上面所有功能 CSS3 3D转换 rotateX() rotateY() CSS3过渡它是如何工作？CSS3过渡是元素从一种样式改变为另一种的效果。 要实现这一点，必须规定两项内容： 指定要添加效果的CSS属性 指定效果的持续时间 实例： 123456div&#123; transition-property: width; transition-duration: 1s;//过渡效果花费的时间1s transition-timing-function: linear;//规定过渡效果的时间曲线 transition_delay: 2;//延迟2秒执行&#125; CSS3动画CSS3@keyframes规则@keyframes规则是创建动画。@keyframes规则内指定一个CSS样式和动画将逐步从目前的样式更改为新的样式。 CSS3动画当在@keyframes创建动画，把它绑定到一个选择器，否则动画不会有任何效果。指定至少这两个CSS3的动画属性绑定向一个选择器： 规定动画的名称 规定动画的时长 CSS3动画是什么？动画是使元素从一种样式逐渐变化为另一种的效果。 你可以改变任意多的样式任意多的次数， 请用百分比来规定变化发生的时间，或用关键词“from”和“to“，等同于0%和100%。 0%是动画开始，100%是动画的完成 CSS3多列CSS3多列属性 column-count column-gap column-rule-style column-rule-width column-rule-color column-rule column-span column-width CSS3 创建多列column-count属性指定了需要分割的列数。 CSS3列与列的间隙column-gap属性指定了列与列间的间隙 CSS3列边框column-rule-style 属性指定了列与列间的边框样式。 column-rule-width属性指定了两列的边框厚度 column-rule-color属性指定两列的边框颜色 指定元素跨越多少列指定列的宽度column-width属性指定了列的宽度 CSS3用户界面 resize box-sizing outline-offset CSS3 调整尺寸CSS3中，resize属性指定一个元素是否应该由用户去调整大小 CSS3 方框大小调整box-sizing属性允许你以确切的方式定义适应某个区域的具体内容 CSS3外形修饰outline-offset属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。 轮廓与边框有两点不同： 轮廓不占用空间 轮廓可能是非矩形 CSS3图片响应式图片响应式图片会自动适配各种尺寸的屏幕 实例： 1234img&#123; max-width: 100%; height: auto;&#125; 图片滤镜CSS filter属性可为元素添加可是效果（例如模糊或饱和度）]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5 初步认识]]></title>
    <url>%2F2017%2F06%2F03%2Fhtml5-%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[HTML5简介什么是HTML5？ HTML5是下一代HTML标准 HTML，HTML4.01的上一个版本诞生于1999年。自从那以后，WEB世界已经经历了巨变、 HTML5仍处于完善中，然而，大部分现代浏览器已经具备了某些HTML5支持 HTML5是如何起步的HTML5的一些有趣的特性: 用于绘画的canvas元素 用于媒介回访的video和audio元素 对本地离线存储的更好的支持 新的特殊内容元素,不如article、footer、header、nav、section 新的表单控件，比如calendar、date、time、email、url、search HTML5 &lt; !DOCTYPE&gt;&lt;!doctype&gt;声明必须位于HTML5文档中的第一行，使用非常简单 1&lt;!DOCTYPE html&gt; HTML5的改进 新元素 新属性 完全支持CSS3 Video和Audio 2D/3D制图 本地存储 本地SQL数据 Web应用 HTML5 多媒体使用HTML5你可以简单的在网页中播放视频（video）与音频（audio）。 HTML5 &lt;video&gt; HTML5 &lt;audio&gt; HTML5 应用使用HTML5你可以简单地开发应用 本地数据存储 访问本地文件 本地SQL数据 缓存引用 JavaScript工作者 XHTMLHttpRequest2 HTML5 使用CSS3 新选择器 新属性 动画 2D/3D转换 圆角 阴影效果 可下载的字体 语义元素 标签 描述 &lt;article&gt; 定义页面独立的内容区域 &lt;aside&gt; 定义页面的侧边栏内容 &lt;bdi&gt; 允许你设置一段文本，使其脱离其父元素的文本方法设置 &lt;command&gt; 定义命令按钮，比如单选按钮、复选框或按钮 &lt;dialog&gt; 定义对话框，比如提示框 &lt;summary&gt; 标签包含details元素的标题 &lt;figure&gt; 规定独立的流内容（图像、图表、照片、代码等） &lt;figcaption&gt; 规定&lt;figure&gt;元素的标题 &lt;footer&gt; 规定section或document的页脚 &lt;header&gt; 规定了文档的头部区域 &lt;mark&gt; 定义带有记号的文本 &lt;meter&gt; 定义度量衡。仅用于已知最大和最小值的度量 &lt;nav&gt; 定义导航链接的部分 &lt;progress&gt; 定义任何类型的任务的进度 &lt;ruby&gt; 定义ruby注释 &lt;rt&gt; 定义字符的解释或发音 &lt;section&gt; 定义文档中的节 &lt;time&gt; 定义日期或时间 &lt;wbr&gt; 规定在文本中的何处适合添加换行符 HTML5表单新表单元素，新属性，新输入类型，自动验证 将HTML5元素定义为块元素HTML5定义8个新的HTML语义元素。所有这些元素都是块级元素 为了能让旧版本的浏览器正确显示这些元素，你可以设置CSS的display属性值为block 123header,section,footer,aside,nav,main,article,figure&#123; display:block;&#125; HTML5新元素canvas新元素标签定义图形，比如图表和其他图像。该标签基于JavaScript的绘图API 新多媒体元素 标签 描述 &lt;audio&gt; 定义音频内容 &lt;video&gt; 定义视频 &lt;source&gt; 定义多媒体资源&lt;video&gt;和&lt;audio&gt; &lt;embed&gt; 定义嵌入的内容，比如插件 &lt;track&gt; 位诸如&lt;video&gt;和&lt;audio&gt;元素之类的媒介规定外部文本轨道 新表单元素 标签 描述 &lt;datalist&gt; 定义选项列表。请与input元素配合使用该元素，来定义input可能的值 &lt;keygen&gt; 规定用于表单的密钥对生成器字段 &lt;output&gt; 定义不同类型的输出，比如脚本的输出 已经移除的元素 &lt;acronym&gt; &lt;applet&gt; &lt;basefont&gt; &lt;big&gt; &lt;center&gt; &lt;dir&gt; &lt;font&gt; &lt;frame&gt; &lt;frameset&gt; &lt;noframes&gt; &lt;strike&gt; &lt;tt&gt; HTML5 Canvas &lt;canvas&gt;标签定义图形，比如图表和其他图像，你必须使用脚本来绘制图形 创建一个画布（Canvas）简单实例： 1&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt; 注意：标签通常需要制定一个id属性（脚本中经常）,width和height属性定义的画布的大小 使用JavaScript来绘制图像canvas元素本身是没有绘图能力的。所有的绘制工作必须在JavaScript内部完成。 实例： 1234var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.fillStyle=&quot;#FF0000&quot;；ctx.fillRect(0,0,150,75); 分析 首先，找到&lt;canvas&gt;元素 然后创建context对象 getContext(“2d”)对象是内建的HTML5对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 设置fillStyle属性可以是CSS颜色，渐变、或图案。fillStyle默认设置是#000000(黑色) fillRect(x,y,width,height)方法定义了矩形当前的填充方式 Canvas 坐标canvas的左上角坐标为（0,0） 上面的fillRect方法拥有参数(0,0,150,75). 意思是：在画布上绘制150×75的矩形，从左上角(0,0)开始。 Canvas-路径在Canvas上画直线，可以使用以下两种方法： moveTo(x,y)定义线条开始坐标 lineTo(x,y)定义线条结束坐标 绘制线条我们必须使用“ink”方法，就像stroke()方法来绘制线条 12345var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.moveTo(0,0);ctx.lineTo(200,100);ctx.stroke(); 在canvas绘制圆形 arc(x,y,r,start,stop) 12345var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();ctx.arc(95,50,40,0,2*Math.PI);ctx.stroke(); Canvas-文本使用canvas绘制文本，重要的属性和方法如下： font-定义字体 fillText(text,x,y)-在canvas上绘制实心的文本 strokeText(text,x,y)- 在canvas上绘制空心的文本 Canvas-渐变渐变可以填充周期矩形，圆形，线条，文本等等，各种形状可以自己定义不同的颜色。 以下有两种不同的方式来设置Canvas渐变： createLinearGradient(x,y,x1,y1)-创建线条渐变 createRadialGradient(x,y,r,x1,y1,r1)-创建一个径向/圆渐变 当我们使用渐变对象，必须使用两种或两种以上的停止颜色。 addColorStop()方法指定颜色停止，参数使用坐标来描述，可以使0至1 使用渐变，设置fillStyle或strokeStyle的值为渐变，然后绘制形状，如矩形，文本，或一条直线。 1234567var c=document.getElementById(&quot;myCanvas&quot;);var context=c.getContext(&quot;2d&quot;);var grd=context.createLinearGradient(0, 0, 200, 0);grd.addColorStop(0, &apos;red&apos;);grd.addColorStop(1, &apos;blue&apos;);context.fillStyle=grd;context.fillRect(10,10,150,80); Canvas-图像把一幅图像放置到画布上，使用以下方法： drawImage（image,x,y) HTML5 内联SVG什么是SVG SVG指可伸缩矢量图形 SVG用于定义用于网络的基于矢量的图形 SVG使用XML格式定义图形 SVG图像在放大或改变尺寸的情况下其图形质量不会有损失 SVG是万维网联盟的标准 SVG的优势与其他图像格式相比，使用SVG的优势： SVG图像可以通过文本编辑器来创建和修改 SVG图像可被搜索、索引、脚本化或压缩 SVG是可伸缩的 SVG图像可在任何的分辨率下被高质量地打印 SVG可在图像质量不下降的情况下被放大 SVG与Canvas的区别 SVG是一种使用XML描述2D图形的语言。 Canvas通过JavaScript来绘制2D图形 SVG基于XML，这意味着SVG DOM中的每个元素都是可用的。你可以为某个元素附加JavaScript事件处理器 在SVG中每个被绘制的图形均被视为对象。如果SVG对象的属性发火说呢过变化，那么浏览器能够自动重现图形 Canvas是逐像素进行渲染的。在canvas中，一旦图形被绘制完成，它就不会继续得到浏览器关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或已被图形覆盖的对象 Canvas SVG 依赖分辨率 不依赖分辨率 不支持事件处理器 支持事件处理器 弱的文本渲染能力 最适合带有大型渲染区域的应用程序（比如谷歌地图） 能够以.png或。jpg格式保存结果图形 复杂度高会减慢渲染速度 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 不适合游戏应用 HTML5 MathMLHTML5可以再文档中时MathML元素，对应的标签是\ MathML是数学标记语言，是一种基于XML的标准，用来在互联网上书写数学符号和公式的置标语言 Chrome浏览器不能用，火狐可以 HTML5 拖放拖放(Drag和Drop)是HTML5标准的组成部分 拖放拖放是一种常见的特性，即抓取对象以后拖到另一个位置 在HTML5中，拖放是标准的一部分，任何元素都能够拖放。 实例: 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;#div1 &#123;width:350px;height:70px;padding:10px;border:1px solid #aaaaaa;&#125;&lt;/style&gt;&lt;script&gt;function allowDrop(ev)&#123; ev.preventDefault();&#125; function drag(ev)&#123; ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125; function drop(ev)&#123; ev.preventDefault(); var data=ev.dataTransfer.getData(&quot;Text&quot;); ev.target.appendChild(document.getElementById(data));&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;拖动 RUNOOB.COM 图片到矩形框中:&lt;/p&gt; &lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;img id=&quot;drag1&quot; src=&quot;/images/logo.png&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; width=&quot;336&quot; height=&quot;69&quot;&gt; &lt;/body&gt;&lt;/html&gt; 解析： 设置元素为可拖放首先，为了使元素可拖动，把draggable属性设置为true： 1&lt;img draggable=&quot;true&quot;&gt; 拖动什么-ondragstart和setDate()然后，规定元素被拖动时，会发生什么。 在上面例子上，ondragstart属性调用一个函数，drag(event),规定了被拖动的数据。dataTransfer.setDate()方法设置被拖数据的数据类型和值： 123function drag(ev)&#123; ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125; 这个例子中，数据类型是“Text”,值是可拖动元素的id(“drag1”) 放在何处- ondragoverondragover事件规定在何处放置被拖动的数据， 默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。 这要通过调用ondragover事件的event.preventDefault()方法： 1event.preventDefault() 进行放置- ondrop当放置被拖数据时，会发生drop事件 在上面例子中，ondrop属性调用一个函数，drop(event): 12345function drop(ev)&#123; ev.preventDefault(); var data=ev.dataTransfer.getData(&quot;Text&quot;); ev.target.appendChild(document.getElementById(data));&#125; 解释： 调用preventDefault()来避免浏览器对数据的默认处理 通过dataTransfer.getData(“Text”)方法获得被拖数据。该方法将返回在setData()方法中设置为相同类型的任何数据。 被拖数据是被拖元素的id(“drag1”) 把被拖元素追加到放置元素中 HTML5 Geolocation(地理定位)HTML5 Geolocation用于定位用户的位置。 HTML5-使用地理定位使用getCurrentPosition()方法来获取用户的位置 实例 123456789101112var x=document.getElementById(&quot;demo&quot;);function getLocation()&#123; if(navigator.geolocation)&#123; navigator.geolocation.getCurrentPosition(showPosition); &#125; else&#123; x.innnerHTML=&quot;该浏览器不支持获取地理位置&quot; &#125;&#125;function showPosition(position)&#123; x.innerHTML=&quot;维度：&quot;+position.coords.latitude+&quot;&lt;br&gt;经度：&quot;+position.coords.longitude;&#125; 检测是否支持地理定位 如果支持，则运行getCurrentPosition()方法，如果不支持，则向用户显示一段消息。 如果getCurrentPosition()运行成功，则向参数showPosition中规定的函数返回一个coordinates对象。 showPosition()函数获得并显示经度和纬度 上面例子是一个非常基础的地理位置定位脚本，不含有错误处理 处理错误和拒绝getCurrentPosition()方法第二个参数用于处理错误，： 123456789101112131415161718function showError(error)&#123; switch(error.code) &#123; case error.PERMISSION_DENIED： x.innerHTML=&quot;用户拒绝获取地理位置的请求。&quot; break; case error.POSITION_UNAVAILABLE: x.innerHTML=&quot;位置信息不可用的。&quot; break; case error.TIMEOUT: x.innerHTML=&quot;请求用户地理位置超时&quot; break; case error.INKNOWN_ERROR: x.innerHTML=&quot;未知错误&quot; break; &#125;&#125; HTML5 VideoHTML5 提供了播放音频文件的标准。 HTML5 Audio - 如何工作实例： 12345&lt;audio controls&gt; &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;&gt; 你的浏览器不支持audio元素&lt;/audio&gt; control属性供添加播放、暂停和音量控件 在&lt;audio&gt;与&lt;/audio&gt;之间你需要插入浏览器不支持的&lt;audio&gt;元素的提示文本 HTML5 Audio 标签 标签 描述 &lt;audio&gt; 定义了声音内容 &lt;source&gt; 规定了多媒体资源，可以是多个，在&lt;video&gt;与&lt;audio&gt;之间使用 HTML5 input类型 color date datetime datetime-local email month number range search tel time url week HTML5 表单元素HTML5新的表单元素 &lt;datalist&gt; &lt;keygen&gt; &lt;output&gt; HTML5&lt;datelist&gt;元素&lt;datelist&gt;元素规定输入域的选项列表。 &lt;datelist&gt;属性规定form或input域应该拥有自动完成功能。当用户在自动完成于域中开始输入时，浏览器应该在该域中显示填写的选项： 使用&lt;input&gt;元素的列表属性与&lt;datalist&gt;元素绑定 实例 12345678&lt;input list=&quot;browsers&quot;&gt;&lt;datalist id=&quot;browsers&quot;&gt; &lt;option value=&quot;Internet Explorer&quot;&gt; &lt;option value=&quot;Firefox&quot;&gt; &lt;option value=&quot;Chrome&quot;&gt; &lt;option value=&quot;Opera&quot;&gt; &lt;option value=&quot;Safari&quot;&gt;&lt;/datalist&gt; HTML5&lt;keygen&gt;元素&lt;keygen&gt;元素的作用是提供一种验证用户的可靠方法。 规定用于表单的密钥对生成器字段 HTML5&lt;output&gt;元素&lt;output&gt;元素用于不同类型的输出，比如计算或脚本输出 HTML5 表单属性HTML5的&lt;form&gt;和&lt;input&gt;标签添加了几个新属性。 &lt;form&gt;新属性 autocomplete novalidate &lt;input&gt;新属性 autocomplete autofocus form formaction formenctype formmethod formnovalidate formtarget height与width list min与max multiple pattern（regexp） placeholder required step form/input autocomplete属性autocomplete属性规定form或input域应该拥有自动完成功能。 当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项。 autocomplete适用于&lt;form&gt;标签，以及以下类型的&lt;input&gt;标签：text，search，url，telephone，email。passsword，datepickers，range以及color novalidate属性novalidate属性石一个boolean属性 novalidate属性规定在提交表单时不应该验证form或input域 autofocus属性autofocus属性是一个boolean属性。 autofocus属性规定在页面加载时，域自动地获得焦点 实例： 1First name:&lt;input type=&quot;text&quot; name=&quot;fname&quot; autofocus&gt; form属性form属性规定输入域所属的一个或多个表单 formaction属性The formaction属性用于描述表单提交的URL地址 The formaction属性会覆盖\元素中的action属性 formenctype属性formenctype属性描述了表单提交到服务器的数据编码(只对form表单中method=“post”表单) formmethod属性formmethod属性定义了表单提交的方式 formmethod属性覆盖&lt;form&gt;元素的method属性 该属性可以与type=“submit”和type=“image”配合 formnovalidate属性novalidate属性石一个boolean属性 novalidate属性描述了&lt;input&gt;元素在表单提交时无需被验证。 formnovalidate属性会覆盖&lt;form&gt;元素的novalidate属性 注意：formnovalidate属性与type=“submit”一起使用 formtarget属性formtarget属性指定一个名称或一个关键字来指明表单提交数据接收后的展示。 formtarget属性会覆盖&lt;form&gt;元素的target属性 height和width属性height和width属性规定用于image类型的&lt;input&gt;标签的图像高度和宽度 list属性list属性规定输入域的datalist。datalist是输入域的选项列表 min和max属性min、max和step属性用于包含数字或日期的input类型规定限定 pattern属性pattern属性描述了一个正则表达式用于验证&lt;&lt;input&gt;元素的值 placeholder属性 placeholder属性提供了一宗提示，描述输入域所期待的值 required属性required属性是一个boolean属性 required属性规定必须在提交之前填写输入域（不能为空） step属性step属性为输入域规定合法的数字间隔。 HTML5的语义元素什么是语义元素？ 一个语义元素能够清楚的描述其意义给浏览器和开发者。 section元素 section标签定义文档中的节。比如章节、页眉、页脚或文档中其他部分 article元素 article标签定义独立的内容 nav元素 nav标签定义导航链接的部分 aside元素 aside标签定义页面主区域之外的内容(比如侧边栏) header元素 header元素描述了文档的头部区域 header元素注意用于定义内容的介绍展示区域 footer元素 footer元素描述了文档的底部区域 HTML5 Web存储什么是HTML5 Web存储使用HTML5可以在本地存储用户的浏览数据 localStorage和sessionStorage客户端存储数据的两个对象为： localStorage -没有时间限制的数据存储 sessionStorage -针对一个session的数据存储 localStorage对象localStorage对象存储的数据没有时间限制。 sessionStorage对象sessionStorage方法针对一个session进行数据存储。当用户关闭浏览器窗口后，数据会被删除 HTML5 应用程序缓存 使用HTML5，通过创建cache manifest文件，可以轻松创建web应用的离线版本。 什么是应用程序缓存(Application Cache) HTML5 引入了应用程序缓存，这意味着web应用可以进行缓存，并可在没有因特网连接时进行访问。应用程序缓存为应用带来三个优势： 离线浏览 用户可在应用离线时使用它们 速度 已缓存资源加载会很快 减少服务器负载 浏览器将只从服务器下载更新过或更改过的资源。 实例： 123456&lt;!DOCTYPE HTML&gt;&lt;html manifest="demo.appcache"&gt;&lt;body&gt; 文档内容&lt;/body&gt; &lt;/html&gt; Cache Manifest基础如需启用应用程序缓存，请在文档的&lt;html&gt;标签中包含manifest 属性； 每个指定了manifest的页面在用户对其访问时都会被缓存。如果未指定manifest属性，则页面不会被缓存。 manifest文件的建议的文件扩展名是：”.appcache”。 Manifest 文件mainfest文件是简单的文本文件，它告知浏览器被缓存的内容(以及不缓存的内容)。 manifest文件可分为三个部分： CACHE MANIFEST -在此标题下列出的文件将在首次下载后进行缓存 NETWORK -在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK -在此标题列出的文件规定在当前页面无法访问时的回退页面(比如404页面) CACHE MANIFEST基本格式 CHAHE MANIFEST /theme.css /logo.gif /main.js 上面的manifest文件列出三个资源：一个CSS文件，一个GIF图像，以及一个JavaScript文件。当manifest文件加载后，浏览器会从网站的根目录下载这三个文件。然后，无论用户何时与因特网断开连接，这些资源依然是可用的。 NETWORK下面的NETWORK小节规定文件”login.php”永远不会被缓存，且离线时不可用的： NETWORK: login.php 可以使用星号来指定所有资源/文件都需要因特网连接： NETWORK: * FALLBACK下面的FALLBACK小节规定如果无法建立因特网连接，则用”offline.html“替代/html5/目录中的所有文件： FALLBACK： /html/offline.html 注意：第一个URL是资源，第二个是替补。 更新缓存一旦应用被缓存，它就会保持缓存知道发生下列情况： 用户情况浏览器缓存 manifest文件被修改 有程序来更新应用缓存 HTML5 Web Workersweb worker是运行在后台的JavaScript，不会影响页面的性能。 计数器的创建工程：创建web worker文件首先，在一个外部JavaScript中创建我们的web worker。 在这里我们创建计数脚本，该脚本存储于”demo_worker.js”文件中： 1234567var i=0;function timeCount()&#123; i=i+1; postMessage(i); setTimeout("timeCount()",500);&#125;timeCount(); postMessage()方法用于向HTML页面传回一段消息 创建Web Worker对象我们已经有web worker文件，现在我们需要从HTML页面调用它。 下面的代码检测是否存在worker，如果不存在，它会创建一个新的web worker对象，然后运行”demo_worker.js”中的代码 1234if(typeof(W)=="undefined") &#123; w=new Work("demo_worker.js") &#125; 然后我们就可以从web worker发生和接收消息了。 向web worker添加一个”onmesssage”事件监听器 123w.onmessage=function(event)&#123; document.getElementById("result").innerHTML=event.data;&#125;; 终止Web Worker当我们创建web worker对象后，它会继续监听消息知道其被终止为止。如需终止web worker，并释放浏览器/计算机资源，请使用terminate()方法： 1w.terminate(); Web Worker和DOM由于web worker位于外部文件中，它们无法访问下例JavaScript对象： window对象 document对象 parent对象 HTML5 服务器发送事件HTML5服务器发送事件允许网页获得来自服务器的更新 Server-Sent事件 -单向消息传递Server-Sent事件指的是网页自动获取来自服务器的更新 接收Server -Sent事件通知EventSource对象用于接收服务器发送事件通知： 12345var source=new EventSource("demo_see.php");source.onmessage=function(event)&#123; document.getElementById("result").innerHTML+="&lt;br&gt;" &#125; EventSource对象 事件 描述 onopen 当通往服务器的连接被打开 onmessaged 当接收到消息 onerror 当发生错误 HTML5 WebSocket 这个等下次认真搞一遍 WebSocket是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JSON必知必会》读书笔记]]></title>
    <url>%2F2017%2F05%2F25%2Fjson%2F</url>
    <content type="text"><![CDATA[将之前写在onenote的关于json的简要知识点改写成md。 JSON笔记第一章 什么是JSON JSON指的是JavaScript对象表示法（JavaScript Object Notation） JSON是轻量级的文本数据交换格式 JSON独立于语言 JSON具有自我描述性，更易理解 JSON使用JavaScript语法来描述数据对象，但是JSON独立于语言和平台。JSON解析器和JSON库之处许多不同的编程语言。目前非常多的动态（PHP、JSP、.NET）编程语言都支持JSON。 第二章 JSON的语法JSON中的名称—值对的名称如果被系统作为对象装入内存的话，将会成为”属性“，不同于名称，值并不是总是需要被双引号包裹。当值是字符串时，必须使用双引号。而在JSON中，数字、布尔值、数组、对象、null等其他类型，这些都不应该被双引号包裹。 例如： 12345678910111213&#123; title："this is my title"&#125;//不合法&#123; 'title':'this is my title'&#125;//同样不合法&#123; "title":"this is my title"&#125;//合法的书写&#123; "value":12 "result":true&#125;//这些都不加双引号 JSON的名称始终被双引号包裹 JSON文件使用.json扩展名 第三章 JSON的数据结构JSON的数据类型： 对象 字符串 数字 布尔值 null 数组 基本嵌套格式 1234567891011121314&#123; "person":&#123; "name":"Lindasy Bassett", "heightInInches":66, "head":&#123; "hair":&#123; "color":"light blood", "length":"short", "style":"A-line" &#125;, "eyes":"green" &#125; &#125;&#125; 注意事项： 遇到双引号、反斜线、\/（正斜线）、\b、\f、\t、\n、\r都需要进行转义（加\） 在JSON中布尔值仅能用true和false表示，任何其他形式的写法都会报错（所有字母必须要小写）。 对象和数组很关键的一个区别就是，对象是名称-值对构成的列表或者集合，数组是值构成的列表或者集合。 对象和数组另一个关键的区别是，数组中所有的值应具有相同的的数据类型。 第四章 JSON Schema基础概念 jsonschema是描述你的JSON数据格式；JSON模式（应用程序/模式+ JSON）有多种用途，其中之一就是实例验证。验证过程可以是交互式或非交互式的。例如，应用程序可以使用JSON模式来构建用户界面使互动的内容生成除了用户输入检查或验证各种来源获取的数据。 基本格式 12345678910111213141516&#123; "schema":"http://json-schame.org/draft-04/shema", "title":"Cat",//文件标题 "properties":&#123; "name":&#123; "type":"string" &#125;, "age":&#123; "tyep":"number", "description":"Your cat's age in year" &#125;, "declawd":&#123; "type":"boolean" &#125; &#125;&#125; “required”，值为一个数组，数组中含必填的字段。如果你的JSON Schema中不含”required“名称–值对，那么将不必有必填项。 总结： JSON Schema是数据交换中的一种虚拟的”合同“ JSON验证器负责验证语法错误，JSON Schema负责提供一致性检验 JSON Schema可以解决下列有关一致性检验的问题。 ——值的数据类型是否正确？ ​ 可以具体规定一个值是数字、字符串等类型 ——是否包含所需要的数据 可以具体规定哪些数据是需要的，哪些是不需要的 ——值的形式是否是我需要的？ 可以指定范围、最小值、最大值。 第六章 JavaScript中的XMLHTTPRequest与Web API基本格式 12345678910var xml=new XMLHTTPRequest();var url="#";xml.onreadystatechange=function()&#123; if(xml.readyState===4 &amp;&amp; xml.state===200)&#123; var myObject = JSON.parse(xml.responseText); var myJSON = JSON.stringify(myObject); &#125;&#125;xml.open("GET",url,true);xml.send(); JSON.parse:反序列化操作，JSON解析成JavaScript对象 JSON.stringify:序列化操作，将JavaScript对象解析成JSON JavaScript中的XMLHttpRequest负责在客户端发起请求，而web API负责在服务端返回响应 XMLHTTPRequest主要属性含义 onreadystatechange 可以在代码中给它赋值为一个函数 readyState 返回一个0~4的值，用来表示状态码 status 返回Http状态码（如200请求表示成功） responseText 当请求成功时，该属性会包含作为文本的响应体 ​]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS高程复习]]></title>
    <url>%2F2017%2F05%2F25%2FJS%E9%AB%98%E7%A8%8B%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[&ensp; 之前在学JS基础的时候已经刷过一次，只不过上次很多东西没错，最近忙于暑期实习，所以特意又将这本书再刷一遍，在仔细作一遍笔记，把之前遗落的知识点重新学习一下。主要记一点面试的知识点。 17/5/25 第一章 JavaScript简介JavaScript实现一个完整的JavaScript实现包括三个不同的部分组成 核心(ECMAScript) 文档对象模型(DOM) 浏览器对象（BOM） ECMAScript即是JS的标准，目前已经到ES6。 DOM简单理解就是HTML内容 第二章 在HTML中使用JavaScript&lt;\script&gt;元素标签的位置 html文件是自上而下的执行方式，但引入的css和javascript的顺序有所不同，css引入执行加载时，程序仍然往下执行，而执行到&lt;\script&gt;脚本是则中断线程，待该script脚本执行结束之后程序才继续往下执行。所以，一般将script放在body之后是因为避免长时间执行script脚本而延迟阻塞。而有一些页面的效果的实现，是需要预先动态的加载一些js脚本，所以这些脚本应该放在&lt;\body&gt;之前。其次，不能将需要访问dom元素的js放在body之前，因为此时还没有开始生成dom，所以在body之前的访问dom元素的js会出错，或者无效。就是因为这个，在dom没生成好时我就给它添加了方法，才导致这样 延迟脚本defer只能适用外部脚本文件 defer属性的用于是表明脚本在执行的时候不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后在运行。因此在&lt;\script&gt;元素中设置defer属性，想当于告诉浏览器立即下载，但延迟执行。 异步脚本HTML5为&lt;\script&gt;开始设置一个async属性，这个属性与defer属性相似，都用于改变处理脚本的行为。同样只是适用脚本文件。 defer与async的差异 123&lt;script src="myscript.js"&gt;&lt;/script&gt;&lt;script async src="myscript.js"&gt;&lt;/script&gt;&lt;script defer src="myscript.js"&gt;&lt;/script&gt; 下面是stackoverflow上的回答，可以参考一下： Without async or defer, browser will run your script immediately, before rendering the elements that’s below your script tag. With async (asynchronous), browser will continue to load the HTML page and render it while the browser load and execute the script at the same time. With defer, browser will run your script when the page finished parsing. (not necessary finishing downloading all image files. This is good.) 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。 高程中解释： 使用defer属性可以让脚本在文档中完全呈现之后再执行，延迟脚本总是按照指定他们的顺序执行。 使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照他们在页面中出现的顺序。 第三章 基本概念语法ECMAScript是明确区分大小写的 变量 虽然省略var操作符可以定义全局变量，但这也不是我们推荐的做法。因为在局部作用域中定义的全局变量很难维护，而且如果有意地省略var操作符，也会由于相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式下回导致抛出ReferenceError错误。 数据类型ES有5种基本数据类型:Undefined、Null、Boolean、Number和String，还有一种复杂数据类型Object。 对未初始化的变量执行typeof操作符会返回undefined值，而对未声明的变量执行typeof操作符同样也会返回undefined值。 操作符加性操作符如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来。 如果只有一个操作数是字符串，则将另一个操作数转换成字符串，然后再将两个字符串拼接起来。 相等操作符W3的说明： Operator Description == equal to === equal value andequal type ！= not equal ！== not equal value or not equal type]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript高程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解HTTP]]></title>
    <url>%2F2017%2F05%2F24%2FREADME%2F</url>
    <content type="text"><![CDATA[图解HTTP 点这里 第一章 第二章 第三章 第四章 第五章 第六章 第七章 第八章 第九章]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2017%2F05%2F24%2FAjax%2F</url>
    <content type="text"><![CDATA[Ajax教程 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 Ajax应用 运用XHTML+CSS来表达资讯； 运用JavaScript操作DOM（Document Object Model）来执行动态效果； 运用XML和XSLT操作资料; 运用XMLHttpRequest或新的Fetch API与网页服务器进行异步资料交换； 注意：AJAX与Flash、Silverlight和Java Applet等RIA技术是有区分的。 Ajax工作原理图列: Ajax创建对象 XMLHttpRequest是Ajax的基础 XMLHTTPRequest 对象XMLHTTPRequest用于在后台与服务器交换数据。这意味着可以再不重新加载整个网页情况下，对网页的某部分进行更新。 创建XMLHTTPRequest1variable = new XMLHTTPRequest(); 老版本的IE浏览器使用ActiveX对象 1variable = new ActiveXObject("Microsoft.XMLHTTP"); 为了应对所有浏览器，故采用下列写法 1234567891011var xmlhttp;if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest();&#125;else&#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");&#125; Ajax 向服务器发送请求 XMLHttPRequest对象用于和服务器交换数据 向服务器发送请求如需将强求发送服务器，我们使用XMLHttpRequest对象的open()和send()方法 12xmlhttp.open("GET","ajax_info.txt",true);xmlhttp.send(); 方法 描述 open（method,url,async) 规定请求的类型、URL以及是否异步处理请求 send(string) 将请求发送到服务器 !仅用于POST请求 GET和POST的区别与POST相比，GET更简单也更快 然而，在以下情况中，请使用POST请求 无法使用缓存文件（更新服务器的文件或数据） 向服务器发送大量数据（POST没有数据量限制） 发送包含未知字符的用户输入时，POST比GET更稳定也更可靠 GET请求一个简单的GET请求 12xmlhttp.open("GET","/try/ajax/demo_get.php",true);xmlhttp.send(); 可是上面的例子你可能得到的是缓存的结果，为了避免这种情况，向URL添加一个唯一的ID 例如： 12xmlhttp.open("GET","/try/ajax/demo_get.php?t="+Math.random(),true);xmlhttp.send(); Math.random()是数学随机数的意思 POST请求例子 12xmlhttp.open("POST","/try/ajax/demo_post.php",true);xmlhttp.send(); POST也可以像HTML表单那样POST数据，请使用setRequestHeader()来添加HTTP头。然后在send()方法中规定你希望发送的数据 实例： 123xmlhttp.open("POST","/try/ajax/demo_post2.php",true);xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");xmlhttp.send("fname=Henry&amp;lname=Ford"); way description setRequestHeader(header,value) 向请求添加HTTP头。- header：规定头的名称- value：规定头的值 url-服务器上的文件open()方法的url参数是服务器上文件的地址 1xmlhttp.open("GET","ajax_test.html",true); 异步 True或False？通过AJAX，JavaScript无需等待服务器的响应，而是： 在等待服务器响应时执行其他的脚本 当响应就绪后响应进行处理###Async=true 当使用async=true的时候，规定在响应处于onreadystatechange事件中的就绪状态时执行的函数 ###Async=false如果需要async=false，请将open()方法中的第三个参数改为false。 我们不推荐使用async=false，但对于一些小型的请求也是可以的。 请记住，JavaScript会等到服务器响应就绪才继续执行。如果服务器繁忙或者缓慢，应用程序会挂机或停止 Ajax-服务器 响应服务器响应如需获得来自服务器的响应，请使用XMLHttpRequest对象的responseText或responseXML属性。 属性 描述 responseText 获得字符串形式的响应数据 responseXML 获得XML形式的响应数据 responseText的实例响应不是XML 1document.getElementById("myDiv").innerHTML=xmlhttp.resposeText; 响应是XML，则采用respondText属性，实例 12345678xmlDoc=xmlhttp.responseXML;txt="";x=xmlDoc.getElementsByTagName("ARTIST");for (i=0;i&lt;x.length;i++)&#123; txt=txt + x[i].childNodes[0].nodeValue + "&lt;br&gt;";&#125;document.getElementById("myDiv").innerHTML=txt; Ajax - onreadystatechange事件当请求被发送到服务器时，我们需要执行一些基于响应的任务 每单readyState改变时，就会触发onreadystatechange事件. readyState 属性存在XMLHttpRequest的状态信息。 下面是XMLHttpRequest 对象的三个重要属性 属性 描述 onreadystatechange 存储函数（或函数名），每readyState属性改变时，就会调用该函数 readyState 存在XMLHttpRequest的状态，从0到4发生变化。0：请求未初始化1：服务器连接已建立 2：请求已接受 3：请求处理中 4：请求已完成，且响应已就绪 status 200：“OK” 404：没有找到页面 在onreadystatechange时间中，我们规定当服务器响应已做好被处理的准备时所执行的任务 当readyState等于4且状态为200时，表示响应已就绪。 具体例子 123456xmlhttp.onreadystatechange=function()&#123; if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200) &#123; document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125;&#125; 使用回调函数如果你的网站上有多个AJAX任务，那么你应该创建XMLHTTPRequest对象编写出一个标准的函数，并为每个AJAX任务调用该函数。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[resume]]></title>
    <url>%2F2017%2F05%2F24%2Fresume%2F</url>
    <content type="text"><![CDATA[简历的照片贴在md中。如果要看html文件或者pdf源文件​点击这，我的github]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>resume</tag>
        <tag>about</tag>
      </tags>
  </entry>
</search>