<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[html5 初步认识]]></title>
    <url>%2F2017%2F06%2F03%2Fhtml5-%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[HTML5简介什么是HTML5？ HTML5是下一代HTML标准 HTML，HTML4.01的上一个版本诞生于1999年。自从那以后，WEB世界已经经历了巨变、 HTML5仍处于完善中，然而，大部分现代浏览器已经具备了某些HTML5支持 HTML5是如何起步的HTML5的一些有趣的特性: 用于绘画的canvas元素 用于媒介回访的video和audio元素 对本地离线存储的更好的支持 新的特殊内容元素,不如article、footer、header、nav、section 新的表单控件，比如calendar、date、time、email、url、search HTML5 &lt; !DOCTYPE&gt;&lt;!doctype&gt;声明必须位于HTML5文档中的第一行，使用非常简单 1&lt;!DOCTYPE html&gt; HTML5的改进 新元素 新属性 完全支持CSS3 Video和Audio 2D/3D制图 本地存储 本地SQL数据 Web应用 HTML5 多媒体使用HTML5你可以简单的在网页中播放视频（video）与音频（audio）。 HTML5 &lt;video&gt; HTML5 &lt;audio&gt; HTML5 应用使用HTML5你可以简单地开发应用 本地数据存储 访问本地文件 本地SQL数据 缓存引用 JavaScript工作者 XHTMLHttpRequest2 HTML5 使用CSS3 新选择器 新属性 动画 2D/3D转换 圆角 阴影效果 可下载的字体 语义元素 标签 描述 &lt;article&gt; 定义页面独立的内容区域 &lt;aside&gt; 定义页面的侧边栏内容 &lt;bdi&gt; 允许你设置一段文本，使其脱离其父元素的文本方法设置 &lt;command&gt; 定义命令按钮，比如单选按钮、复选框或按钮 &lt;dialog&gt; 定义对话框，比如提示框 &lt;summary&gt; 标签包含details元素的标题 &lt;figure&gt; 规定独立的流内容（图像、图表、照片、代码等） &lt;figcaption&gt; 规定&lt;figure&gt;元素的标题 &lt;footer&gt; 规定section或document的页脚 &lt;header&gt; 规定了文档的头部区域 &lt;mark&gt; 定义带有记号的文本 &lt;meter&gt; 定义度量衡。仅用于已知最大和最小值的度量 &lt;nav&gt; 定义导航链接的部分 &lt;progress&gt; 定义任何类型的任务的进度 &lt;ruby&gt; 定义ruby注释 &lt;rt&gt; 定义字符的解释或发音 &lt;section&gt; 定义文档中的节 &lt;time&gt; 定义日期或时间 &lt;wbr&gt; 规定在文本中的何处适合添加换行符 HTML5表单新表单元素，新属性，新输入类型，自动验证 将HTML5元素定义为块元素HTML5定义8个新的HTML语义元素。所有这些元素都是块级元素 为了能让旧版本的浏览器正确显示这些元素，你可以设置CSS的display属性值为block 123header,section,footer,aside,nav,main,article,figure&#123; display:block;&#125; HTML5新元素&lt;canvas&gt;新元素标签定义图形，比如图表和其他图像。该标签基于JavaScript的绘图API 新多媒体元素 标签 描述 &lt;audio&gt; 定义音频内容 &lt;video&gt; 定义视频 &lt;source&gt; 定义多媒体资源&lt;video&gt;和&lt;audio&gt; &lt;embed&gt; 定义嵌入的内容，比如插件 &lt;track&gt; 位诸如&lt;video&gt;和&lt;audio&gt;元素之类的媒介规定外部文本轨道 新表单元素 标签 描述 &lt;datalist&gt; 定义选项列表。请与input元素配合使用该元素，来定义input可能的值 &lt;keygen&gt; 规定用于表单的密钥对生成器字段 &lt;output&gt; 定义不同类型的输出，比如脚本的输出 已经移除的元素 &lt;acronym&gt; &lt;applet&gt; &lt;basefont&gt; &lt;big&gt; &lt;center&gt; &lt;dir&gt; &lt;font&gt; &lt;frame&gt; &lt;frameset&gt; &lt;noframes&gt; &lt;strike&gt; &lt;tt&gt; HTML5 Canvas &lt;canvas&gt;标签定义图形，比如图表和其他图像，你必须使用脚本来绘制图形 创建一个画布（Canvas）简单实例： 1&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt; 注意：标签通常需要制定一个id属性（脚本中经常）,width和height属性定义的画布的大小 使用JavaScript来绘制图像canvas元素本身是没有绘图能力的。所有的绘制工作必须在JavaScript内部完成。 实例： 1234var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.fillStyle=&quot;#FF0000&quot;；ctx.fillRect(0,0,150,75); 分析 首先，找到&lt;canvas&gt;元素 然后创建context对象 getContext(“2d”)对象是内建的HTML5对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 设置fillStyle属性可以是CSS颜色，渐变、或图案。fillStyle默认设置是#000000(黑色) fillRect(x,y,width,height)方法定义了矩形当前的填充方式 Canvas 坐标canvas的左上角坐标为（0,0） 上面的fillRect方法拥有参数(0,0,150,75). 意思是：在画布上绘制150×75的矩形，从左上角(0,0)开始。 Canvas-路径在Canvas上画直线，可以使用以下两种方法： moveTo(x,y)定义线条开始坐标 lineTo(x,y)定义线条结束坐标 绘制线条我们必须使用“ink”方法，就像stroke()方法来绘制线条 12345var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.moveTo(0,0);ctx.lineTo(200,100);ctx.stroke(); 在canvas绘制圆形 arc(x,y,r,start,stop) 12345var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();ctx.arc(95,50,40,0,2*Math.PI);ctx.stroke(); Canvas-文本使用canvas绘制文本，重要的属性和方法如下： font-定义字体 fillText(text,x,y)-在canvas上绘制实心的文本 strokeText(text,x,y)- 在canvas上绘制空心的文本 Canvas-渐变渐变可以填充周期矩形，圆形，线条，文本等等，各种形状可以自己定义不同的颜色。 以下有两种不同的方式来设置Canvas渐变： createLinearGradient(x,y,x1,y1)-创建线条渐变 createRadialGradient(x,y,r,x1,y1,r1)-创建一个径向/圆渐变 当我们使用渐变对象，必须使用两种或两种以上的停止颜色。 addColorStop()方法指定颜色停止，参数使用坐标来描述，可以使0至1 使用渐变，设置fillStyle或strokeStyle的值为渐变，然后绘制形状，如矩形，文本，或一条直线。 1234567var c=document.getElementById(&quot;myCanvas&quot;);var context=c.getContext(&quot;2d&quot;);var grd=context.createLinearGradient(0, 0, 200, 0);grd.addColorStop(0, &apos;red&apos;);grd.addColorStop(1, &apos;blue&apos;);context.fillStyle=grd;context.fillRect(10,10,150,80); Canvas-图像把一幅图像放置到画布上，使用以下方法： drawImage（image,x,y) HTML5 内联SVG什么是SVG SVG指可伸缩矢量图形 SVG用于定义用于网络的基于矢量的图形 SVG使用XML格式定义图形 SVG图像在放大或改变尺寸的情况下其图形质量不会有损失 SVG是万维网联盟的标准 SVG的优势与其他图像格式相比，使用SVG的优势： SVG图像可以通过文本编辑器来创建和修改 SVG图像可被搜索、索引、脚本化或压缩 SVG是可伸缩的 SVG图像可在任何的分辨率下被高质量地打印 SVG可在图像质量不下降的情况下被放大 SVG与Canvas的区别 SVG是一种使用XML描述2D图形的语言。 Canvas通过JavaScript来绘制2D图形 SVG基于XML，这意味着SVG DOM中的每个元素都是可用的。你可以为某个元素附加JavaScript事件处理器 在SVG中每个被绘制的图形均被视为对象。如果SVG对象的属性发火说呢过变化，那么浏览器能够自动重现图形 Canvas是逐像素进行渲染的。在canvas中，一旦图形被绘制完成，它就不会继续得到浏览器关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或已被图形覆盖的对象 Canvas SVG 依赖分辨率 不依赖分辨率 不支持事件处理器 支持事件处理器 弱的文本渲染能力 最适合带有大型渲染区域的应用程序（比如谷歌地图） 能够以.png或。jpg格式保存结果图形 复杂度高会减慢渲染速度 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 不适合游戏应用 HTML5 MathMLHTML5可以再文档中时MathML元素，对应的标签是\ MathML是数学标记语言，是一种基于XML的标准，用来在互联网上书写数学符号和公式的置标语言 Chrome浏览器不能用，火狐可以 HTML5 拖放拖放(Drag和Drop)是HTML5标准的组成部分 拖放拖放是一种常见的特性，即抓取对象以后拖到另一个位置 在HTML5中，拖放是标准的一部分，任何元素都能够拖放。 实例: 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;#div1 &#123;width:350px;height:70px;padding:10px;border:1px solid #aaaaaa;&#125;&lt;/style&gt;&lt;script&gt;function allowDrop(ev)&#123; ev.preventDefault();&#125; function drag(ev)&#123; ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125; function drop(ev)&#123; ev.preventDefault(); var data=ev.dataTransfer.getData(&quot;Text&quot;); ev.target.appendChild(document.getElementById(data));&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;拖动 RUNOOB.COM 图片到矩形框中:&lt;/p&gt; &lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;img id=&quot;drag1&quot; src=&quot;/images/logo.png&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; width=&quot;336&quot; height=&quot;69&quot;&gt; &lt;/body&gt;&lt;/html&gt; 解析： 设置元素为可拖放首先，为了使元素可拖动，把draggable属性设置为true： 1&lt;img draggable=&quot;true&quot;&gt; 拖动什么-ondragstart和setDate()然后，规定元素被拖动时，会发生什么。 在上面例子上，ondragstart属性调用一个函数，drag(event),规定了被拖动的数据。dataTransfer.setDate()方法设置被拖数据的数据类型和值： 123function drag(ev)&#123; ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125; 这个例子中，数据类型是“Text”,值是可拖动元素的id(“drag1”) 放在何处- ondragoverondragover事件规定在何处放置被拖动的数据， 默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。 这要通过调用ondragover事件的event.preventDefault()方法： 1event.preventDefault() 进行放置- ondrop当放置被拖数据时，会发生drop事件 在上面例子中，ondrop属性调用一个函数，drop(event): 12345function drop(ev)&#123; ev.preventDefault(); var data=ev.dataTransfer.getData(&quot;Text&quot;); ev.target.appendChild(document.getElementById(data));&#125; 解释： 调用preventDefault()来避免浏览器对数据的默认处理 通过dataTransfer.getData(“Text”)方法获得被拖数据。该方法将返回在setData()方法中设置为相同类型的任何数据。 被拖数据是被拖元素的id(“drag1”) 把被拖元素追加到放置元素中 HTML5 Geolocation(地理定位)HTML5 Geolocation用于定位用户的位置。 HTML5-使用地理定位使用getCurrentPosition()方法来获取用户的位置 实例 123456789101112var x=document.getElementById(&quot;demo&quot;);function getLocation()&#123; if(navigator.geolocation)&#123; navigator.geolocation.getCurrentPosition(showPosition); &#125; else&#123; x.innnerHTML=&quot;该浏览器不支持获取地理位置&quot; &#125;&#125;function showPosition(position)&#123; x.innerHTML=&quot;维度：&quot;+position.coords.latitude+&quot;&lt;br&gt;经度：&quot;+position.coords.longitude;&#125; 检测是否支持地理定位 如果支持，则运行getCurrentPosition()方法，如果不支持，则向用户显示一段消息。 如果getCurrentPosition()运行成功，则向参数showPosition中规定的函数返回一个coordinates对象。 showPosition()函数获得并显示经度和纬度 上面例子是一个非常基础的地理位置定位脚本，不含有错误处理 处理错误和拒绝getCurrentPosition()方法第二个参数用于处理错误，： 123456789101112131415161718function showError(error)&#123; switch(error.code) &#123; case error.PERMISSION_DENIED： x.innerHTML=&quot;用户拒绝获取地理位置的请求。&quot; break; case error.POSITION_UNAVAILABLE: x.innerHTML=&quot;位置信息不可用的。&quot; break; case error.TIMEOUT: x.innerHTML=&quot;请求用户地理位置超时&quot; break; case error.INKNOWN_ERROR: x.innerHTML=&quot;未知错误&quot; break; &#125;&#125; HTML5 VideoHTML5 提供了播放音频文件的标准。 HTML5 Audio - 如何工作实例： 12345&lt;audio controls&gt; &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;&gt; 你的浏览器不支持audio元素&lt;/audio&gt; control属性供添加播放、暂停和音量控件 在&lt;audio&gt;与&lt;/audio&gt;之间你需要插入浏览器不支持的&lt;audio&gt;元素的提示文本 HTML5 Audio 标签 标签 描述 &lt;audio&gt; 定义了声音内容 &lt;source&gt; 规定了多媒体资源，可以是多个，在&lt;video&gt;与&lt;audio&gt;之间使用 HTML5 input类型 color date datetime datetime-local email month number range search tel time url week HTML5 表单元素HTML5新的表单元素 &lt;datalist&gt; &lt;keygen&gt; &lt;output&gt; HTML5&lt;datelist&gt;元素&lt;datelist&gt;元素规定输入域的选项列表。 &lt;datelist&gt;属性规定form或input域应该拥有自动完成功能。当用户在自动完成于域中开始输入时，浏览器应该在该域中显示填写的选项： 使用&lt;input&gt;元素的列表属性与&lt;datalist&gt;元素绑定 实例 12345678&lt;input list=&quot;browsers&quot;&gt;&lt;datalist id=&quot;browsers&quot;&gt; &lt;option value=&quot;Internet Explorer&quot;&gt; &lt;option value=&quot;Firefox&quot;&gt; &lt;option value=&quot;Chrome&quot;&gt; &lt;option value=&quot;Opera&quot;&gt; &lt;option value=&quot;Safari&quot;&gt;&lt;/datalist&gt; HTML5&lt;keygen&gt;元素&lt;keygen&gt;元素的作用是提供一种验证用户的可靠方法。 规定用于表单的密钥对生成器字段 HTML5&lt;output&gt;元素&lt;output&gt;元素用于不同类型的输出，比如计算或脚本输出 HTML5 表单属性HTML5的&lt;form&gt;和&lt;input&gt;标签添加了几个新属性。 &lt;form&gt;新属性 autocomplete novalidate &lt;input&gt;新属性 autocomplete autofocus form formaction formenctype formmethod formnovalidate formtarget height与width list min与max multiple pattern（regexp） placeholder required step form/input autocomplete属性autocomplete属性规定form或input域应该拥有自动完成功能。 当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项。 autocomplete适用于&lt;form&gt;标签，以及以下类型的&lt;input&gt;标签：text，search，url，telephone，email。passsword，datepickers，range以及color novalidate属性novalidate属性石一个boolean属性 novalidate属性规定在提交表单时不应该验证form或input域 autofocus属性autofocus属性是一个boolean属性。 autofocus属性规定在页面加载时，域自动地获得焦点 实例： 1First name:&lt;input type=&quot;text&quot; name=&quot;fname&quot; autofocus&gt; form属性form属性规定输入域所属的一个或多个表单 formaction属性The formaction属性用于描述表单提交的URL地址 The formaction属性会覆盖\元素中的action属性 formenctype属性formenctype属性描述了表单提交到服务器的数据编码(只对form表单中method=“post”表单) formmethod属性formmethod属性定义了表单提交的方式 formmethod属性覆盖&lt;form&gt;元素的method属性 该属性可以与type=“submit”和type=“image”配合 formnovalidate属性novalidate属性石一个boolean属性 novalidate属性描述了&lt;input&gt;元素在表单提交时无需被验证。 formnovalidate属性会覆盖&lt;form&gt;元素的novalidate属性 注意：formnovalidate属性与type=“submit”一起使用 formtarget属性formtarget属性指定一个名称或一个关键字来指明表单提交数据接收后的展示。 formtarget属性会覆盖&lt;form&gt;元素的target属性 height和width属性height和width属性规定用于image类型的&lt;input&gt;标签的图像高度和宽度 list属性list属性规定输入域的datalist。datalist是输入域的选项列表 min和max属性min、max和step属性用于包含数字或日期的input类型规定限定 pattern属性pattern属性描述了一个正则表达式用于验证\元素的值 placeholder属性 placeholder属性提供了一宗提示，描述输入域所期待的值 required属性required属性是一个boolean属性 required属性规定必须在提交之前填写输入域（不能为空） step属性step属性为输入域规定合法的数字间隔。 HTML5的语义元素什么是语义元素？ 一个语义元素能够清楚的描述其意义给浏览器和开发者。 section元素 section标签定义文档中的节。比如章节、页眉、页脚或文档中其他部分 article元素 article标签定义独立的内容 nav元素 nav标签定义导航链接的部分 aside元素 aside标签定义页面主区域之外的内容(比如侧边栏) header元素 header元素描述了文档的头部区域 header元素注意用于定义内容的介绍展示区域 footer元素 footer元素描述了文档的底部区域 HTML5 Web存储什么是HTML5 Web存储使用HTML5可以在本地存储用户的浏览数据 localStorage和sessionStorage客户端存储数据的两个对象为： localStorage -没有时间限制的数据存储 sessionStorage -针对一个session的数据存储 localStorage对象localStorage对象存储的数据没有时间限制。 sessionStorage对象sessionStorage方法针对一个session进行数据存储。当用户关闭浏览器窗口后，数据会被删除 HTML5 应用程序缓存 使用HTML5，通过创建cache manifest文件，可以轻松创建web应用的离线版本。 什么是应用程序缓存(Application Cache) HTML5 引入了应用程序缓存，这意味着web应用可以进行缓存，并可在没有因特网连接时进行访问。应用程序缓存为应用带来三个优势： 离线浏览 用户可在应用离线时使用它们 速度 已缓存资源加载会很快 减少服务器负载 浏览器将只从服务器下载更新过或更改过的资源。 实例： 123456&lt;!DOCTYPE HTML&gt;&lt;html manifest="demo.appcache"&gt;&lt;body&gt; 文档内容&lt;/body&gt; &lt;/html&gt; Cache Manifest基础如需启用应用程序缓存，请在文档的&lt;html&gt;标签中包含manifest 属性； 每个指定了manifest的页面在用户对其访问时都会被缓存。如果未指定manifest属性，则页面不会被缓存。 manifest文件的建议的文件扩展名是：”.appcache”。 Manifest 文件mainfest文件是简单的文本文件，它告知浏览器被缓存的内容(以及不缓存的内容)。 manifest文件可分为三个部分： CACHE MANIFEST -在此标题下列出的文件将在首次下载后进行缓存 NETWORK -在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK -在此标题列出的文件规定在当前页面无法访问时的回退页面(比如404页面) CACHE MANIFEST基本格式 CHAHE MANIFEST /theme.css /logo.gif /main.js 上面的manifest文件列出三个资源：一个CSS文件，一个GIF图像，以及一个JavaScript文件。当manifest文件加载后，浏览器会从网站的根目录下载这三个文件。然后，无论用户何时与因特网断开连接，这些资源依然是可用的。 NETWORK下面的NETWORK小节规定文件”login.php”永远不会被缓存，且离线时不可用的： NETWORK: login.php 可以使用星号来指定所有资源/文件都需要因特网连接： NETWORK: * FALLBACK下面的FALLBACK小节规定如果无法建立因特网连接，则用”offline.html“替代/html5/目录中的所有文件： FALLBACK： /html/offline.html 注意：第一个URL是资源，第二个是替补。 更新缓存一旦应用被缓存，它就会保持缓存知道发生下列情况： 用户情况浏览器缓存 manifest文件被修改 有程序来更新应用缓存 HTML5 Web Workersweb worker是运行在后台的JavaScript，不会影响页面的性能。 计数器的创建工程：创建web worker文件首先，在一个外部JavaScript中创建我们的web worker。 在这里我们创建计数脚本，该脚本存储于”demo_worker.js”文件中： 1234567var i=0;function timeCount()&#123; i=i+1; postMessage(i); setTimeout("timeCount()",500);&#125;timeCount(); postMessage()方法用于向HTML页面传回一段消息 创建Web Worker对象我们已经有web worker文件，现在我们需要从HTML页面调用它。 下面的代码检测是否存在worker，如果不存在，它会创建一个新的web worker对象，然后运行”demo_worker.js”中的代码 1234if(typeof(W)=="undefined") &#123; w=new Work("demo_worker.js") &#125; 然后我们就可以从web worker发生和接收消息了。 向web worker添加一个”onmesssage”事件监听器 123w.onmessage=function(event)&#123; document.getElementById("result").innerHTML=event.data;&#125;; 终止Web Worker当我们创建web worker对象后，它会继续监听消息知道其被终止为止。如需终止web worker，并释放浏览器/计算机资源，请使用terminate()方法： 1w.terminate(); Web Worker和DOM由于web worker位于外部文件中，它们无法访问下例JavaScript对象： window对象 document对象 parent对象 HTML5 服务器发送事件HTML5服务器发送事件允许网页获得来自服务器的更新 Server-Sent事件 -单向消息传递Server-Sent事件指的是网页自动获取来自服务器的更新 接收Server -Sent事件通知EventSource对象用于接收服务器发送事件通知： 12345var source=new EventSource("demo_see.php");source.onmessage=function(event)&#123; document.getElementById("result").innerHTML+="&lt;br&gt;" &#125; EventSource对象 事件 描述 onopen 当通往服务器的连接被打开 onmessaged 当接收到消息 onerror 当发生错误 HTML5 WebSocket 这个等下次认真搞一遍 WebSocket是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JSON必知必会》读书笔记]]></title>
    <url>%2F2017%2F05%2F25%2Fjson%2F</url>
    <content type="text"><![CDATA[将之前写在onenote的关于json的简要知识点改写成md。 第一章 什么是JSON JSON指的是JavaScript对象表示法（JavaScript Object Notation） JSON是轻量级的文本数据交换格式 JSON独立于语言 JSON具有自我描述性，更易理解 JSON使用JavaScript语法来描述数据对象，但是JSON独立于语言和平台。JSON解析器和JSON库之处许多不同的编程语言。目前非常多的动态（PHP、JSP、.NET）编程语言都支持JSON。 第二章 JSON的语法JSON中的名称—值对的名称如果被系统作为对象装入内存的话，将会成为”属性“，不同于名称，值并不是总是需要被双引号包裹。当值是字符串时，必须使用双引号。而在JSON中，数字、布尔值、数组、对象、null等其他类型，这些都不应该被双引号包裹。 例如： 12345678910111213&#123; title："this is my title"&#125;//不合法&#123; 'title':'this is my title'&#125;//同样不合法&#123; "title":"this is my title"&#125;//合法的书写&#123; "value":12 "result":true&#125;//这些都不加双引号 JSON的名称始终被双引号包裹 JSON文件使用.json扩展名 第三章 JSON的数据结构JSON的数据类型： 对象 字符串 数字 布尔值 null 数组 基本嵌套格式 1234567891011121314&#123; "person":&#123; "name":"Lindasy Bassett", "heightInInches":66, "head":&#123; "hair":&#123; "color":"light blood", "length":"short", "style":"A-line" &#125;, "eyes":"green" &#125; &#125;&#125; 注意事项： 遇到双引号、反斜线、\/（正斜线）、\b、\f、\t、\n、\r都需要进行转义（加\） 在JSON中布尔值仅能用true和false表示，任何其他形式的写法都会报错（所有字母必须要小写）。 对象和数组很关键的一个区别就是，对象是名称-值对构成的列表或者集合，数组是值构成的列表或者集合。 对象和数组另一个关键的区别是，数组中所有的值应具有相同的的数据类型。 第四章 JSON Schema基础概念 jsonschema是描述你的JSON数据格式；JSON模式（应用程序/模式+ JSON）有多种用途，其中之一就是实例验证。验证过程可以是交互式或非交互式的。例如，应用程序可以使用JSON模式来构建用户界面使互动的内容生成除了用户输入检查或验证各种来源获取的数据。 基本格式 12345678910111213141516&#123; "schema":"http://json-schame.org/draft-04/shema", "title":"Cat",//文件标题 "properties":&#123; "name":&#123; "type":"string" &#125;, "age":&#123; "tyep":"number", "description":"Your cat's age in year" &#125;, "declawd":&#123; "type":"boolean" &#125; &#125;&#125; “required”，值为一个数组，数组中含必填的字段。如果你的JSON Schema中不含”required“名称–值对，那么将不必有必填项。 总结： JSON Schema是数据交换中的一种虚拟的”合同“ JSON验证器负责验证语法错误，JSON Schema负责提供一致性检验 JSON Schema可以解决下列有关一致性检验的问题。 ——值的数据类型是否正确？ ​ 可以具体规定一个值是数字、字符串等类型 ——是否包含所需要的数据 可以具体规定哪些数据是需要的，哪些是不需要的 ——值的形式是否是我需要的？ 可以指定范围、最小值、最大值。 第六章 JavaScript中的XMLHTTPRequest与Web API基本格式 12345678910var xml=new XMLHTTPRequest();var url="#";xml.onreadystatechange=function()&#123; if(xml.readyState===4 &amp;&amp; xml.state===200)&#123; var myObject = JSON.parse(xml.responseText); var myJSON = JSON.stringify(myObject); &#125;&#125;xml.open("GET",url,true);xml.send(); JSON.parse:反序列化操作，JSON解析成JavaScript对象 JSON.stringify:序列化操作，将JavaScript对象解析成JSON JavaScript中的XMLHttpRequest负责在客户端发起请求，而web API负责在服务端返回响应 XMLHTTPRequest主要属性含义 onreadystatechange 可以在代码中给它赋值为一个函数 readyState 返回一个0~4的值，用来表示状态码 status 返回Http状态码（如200请求表示成功） responseText 当请求成功时，该属性会包含作为文本的响应体 ​]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS高程复习]]></title>
    <url>%2F2017%2F05%2F25%2FJS%E9%AB%98%E7%A8%8B%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[&ensp; 之前在学JS基础的时候已经刷过一次，只不过上次很多东西没错，最近忙于暑期实习，所以特意又将这本书再刷一遍，在仔细作一遍笔记，把之前遗落的知识点重新学习一下。主要记一点面试的知识点。 17/5/25 第一章 JavaScript简介JavaScript实现一个完整的JavaScript实现包括三个不同的部分组成 核心(ECMAScript) 文档对象模型(DOM) 浏览器对象（BOM） ECMAScript即是JS的标准，目前已经到ES6。 DOM简单理解就是HTML内容 第二章 在HTML中使用JavaScript&lt;\script&gt;元素标签的位置 html文件是自上而下的执行方式，但引入的css和javascript的顺序有所不同，css引入执行加载时，程序仍然往下执行，而执行到&lt;\script&gt;脚本是则中断线程，待该script脚本执行结束之后程序才继续往下执行。所以，一般将script放在body之后是因为避免长时间执行script脚本而延迟阻塞。而有一些页面的效果的实现，是需要预先动态的加载一些js脚本，所以这些脚本应该放在&lt;\body&gt;之前。其次，不能将需要访问dom元素的js放在body之前，因为此时还没有开始生成dom，所以在body之前的访问dom元素的js会出错，或者无效。就是因为这个，在dom没生成好时我就给它添加了方法，才导致这样 延迟脚本defer只能适用外部脚本文件 defer属性的用于是表明脚本在执行的时候不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后在运行。因此在&lt;\script&gt;元素中设置defer属性，想当于告诉浏览器立即下载，但延迟执行。 异步脚本HTML5为&lt;\script&gt;开始设置一个async属性，这个属性与defer属性相似，都用于改变处理脚本的行为。同样只是适用脚本文件。 defer与async的差异 123&lt;script src="myscript.js"&gt;&lt;/script&gt;&lt;script async src="myscript.js"&gt;&lt;/script&gt;&lt;script defer src="myscript.js"&gt;&lt;/script&gt; 下面是stackoverflow上的回答，可以参考一下： Without async or defer, browser will run your script immediately, before rendering the elements that’s below your script tag. With async (asynchronous), browser will continue to load the HTML page and render it while the browser load and execute the script at the same time. With defer, browser will run your script when the page finished parsing. (not necessary finishing downloading all image files. This is good.) 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。 高程中解释： 使用defer属性可以让脚本在文档中完全呈现之后再执行，延迟脚本总是按照指定他们的顺序执行。 使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照他们在页面中出现的顺序。 第三章 基本概念语法ECMAScript是明确区分大小写的 变量 虽然省略var操作符可以定义全局变量，但这也不是我们推荐的做法。因为在局部作用域中定义的全局变量很难维护，而且如果有意地省略var操作符，也会由于相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式下回导致抛出ReferenceError错误。 数据类型ES有5种基本数据类型:Undefined、Null、Boolean、Number和String，还有一种复杂数据类型Object。 对未初始化的变量执行typeof操作符会返回undefined值，而对未声明的变量执行typeof操作符同样也会返回undefined值。 操作符加性操作符如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来。 如果只有一个操作数是字符串，则将另一个操作数转换成字符串，然后再将两个字符串拼接起来。 相等操作符W3的说明： Operator Description == equal to === equal value andequal type ！= not equal ！== not equal value or not equal type]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript高程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解HTTP]]></title>
    <url>%2F2017%2F05%2F24%2FREADME%2F</url>
    <content type="text"><![CDATA[图解HTTP 点这里 第一章 第二章 第三章 第四章 第五章 第六章 第七章 第八章 第九章]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2017%2F05%2F24%2FAjax%2F</url>
    <content type="text"><![CDATA[Ajax教程 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 Ajax应用 运用XHTML+CSS来表达资讯； 运用JavaScript操作DOM（Document Object Model）来执行动态效果； 运用XML和XSLT操作资料; 运用XMLHttpRequest或新的Fetch API与网页服务器进行异步资料交换； 注意：AJAX与Flash、Silverlight和Java Applet等RIA技术是有区分的。 Ajax工作原理图列: Ajax创建对象 XMLHttpRequest是Ajax的基础 XMLHTTPRequest 对象XMLHTTPRequest用于在后台与服务器交换数据。这意味着可以再不重新加载整个网页情况下，对网页的某部分进行更新。 创建XMLHTTPRequest1variable = new XMLHTTPRequest(); 老版本的IE浏览器使用ActiveX对象 1variable = new ActiveXObject("Microsoft.XMLHTTP"); 为了应对所有浏览器，故采用下列写法 1234567891011var xmlhttp;if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest();&#125;else&#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");&#125; Ajax 向服务器发送请求 XMLHttPRequest对象用于和服务器交换数据 向服务器发送请求如需将强求发送服务器，我们使用XMLHttpRequest对象的open()和send()方法 12xmlhttp.open("GET","ajax_info.txt",true);xmlhttp.send(); 方法 描述 open（method,url,async) 规定请求的类型、URL以及是否异步处理请求 send(string) 将请求发送到服务器 !仅用于POST请求 GET和POST的区别与POST相比，GET更简单也更快 然而，在以下情况中，请使用POST请求 无法使用缓存文件（更新服务器的文件或数据） 向服务器发送大量数据（POST没有数据量限制） 发送包含未知字符的用户输入时，POST比GET更稳定也更可靠 GET请求一个简单的GET请求 12xmlhttp.open("GET","/try/ajax/demo_get.php",true);xmlhttp.send(); 可是上面的例子你可能得到的是缓存的结果，为了避免这种情况，向URL添加一个唯一的ID 例如： 12xmlhttp.open("GET","/try/ajax/demo_get.php?t="+Math.random(),true);xmlhttp.send(); Math.random()是数学随机数的意思 POST请求例子 12xmlhttp.open("POST","/try/ajax/demo_post.php",true);xmlhttp.send(); POST也可以像HTML表单那样POST数据，请使用setRequestHeader()来添加HTTP头。然后在send()方法中规定你希望发送的数据 实例： 123xmlhttp.open("POST","/try/ajax/demo_post2.php",true);xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");xmlhttp.send("fname=Henry&amp;lname=Ford"); way description setRequestHeader(header,value) 向请求添加HTTP头。- header：规定头的名称- value：规定头的值 url-服务器上的文件open()方法的url参数是服务器上文件的地址 1xmlhttp.open("GET","ajax_test.html",true); 异步 True或False？通过AJAX，JavaScript无需等待服务器的响应，而是： 在等待服务器响应时执行其他的脚本 当响应就绪后响应进行处理###Async=true 当使用async=true的时候，规定在响应处于onreadystatechange事件中的就绪状态时执行的函数 ###Async=false如果需要async=false，请将open()方法中的第三个参数改为false。 我们不推荐使用async=false，但对于一些小型的请求也是可以的。 请记住，JavaScript会等到服务器响应就绪才继续执行。如果服务器繁忙或者缓慢，应用程序会挂机或停止 Ajax-服务器 响应服务器响应如需获得来自服务器的响应，请使用XMLHttpRequest对象的responseText或responseXML属性。 属性 描述 responseText 获得字符串形式的响应数据 responseXML 获得XML形式的响应数据 responseText的实例响应不是XML 1document.getElementById("myDiv").innerHTML=xmlhttp.resposeText; 响应是XML，则采用respondText属性，实例 12345678xmlDoc=xmlhttp.responseXML;txt="";x=xmlDoc.getElementsByTagName("ARTIST");for (i=0;i&lt;x.length;i++)&#123; txt=txt + x[i].childNodes[0].nodeValue + "&lt;br&gt;";&#125;document.getElementById("myDiv").innerHTML=txt; Ajax - onreadystatechange事件当请求被发送到服务器时，我们需要执行一些基于响应的任务 每单readyState改变时，就会触发onreadystatechange事件. readyState 属性存在XMLHttpRequest的状态信息。 下面是XMLHttpRequest 对象的三个重要属性 属性 描述 onreadystatechange 存储函数（或函数名），每readyState属性改变时，就会调用该函数 readyState 存在XMLHttpRequest的状态，从0到4发生变化。0：请求未初始化1：服务器连接已建立 2：请求已接受 3：请求处理中 4：请求已完成，且响应已就绪 status 200：“OK” 404：没有找到页面 在onreadystatechange时间中，我们规定当服务器响应已做好被处理的准备时所执行的任务 当readyState等于4且状态为200时，表示响应已就绪。 具体例子 123456xmlhttp.onreadystatechange=function()&#123; if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200) &#123; document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125;&#125; 使用回调函数如果你的网站上有多个AJAX任务，那么你应该创建XMLHTTPRequest对象编写出一个标准的函数，并为每个AJAX任务调用该函数。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[resume]]></title>
    <url>%2F2017%2F05%2F24%2Fresume%2F</url>
    <content type="text"><![CDATA[简历的照片贴在md中。如果要看html文件或者pdf源文件​点击这，我的github]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>resume</tag>
        <tag>about</tag>
      </tags>
  </entry>
</search>