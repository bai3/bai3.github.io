<h1 id="第二章-简单的Http协议"><a href="#第二章-简单的Http协议" class="headerlink" title="第二章 简单的Http协议"></a>第二章 简单的Http协议</h1><h2 id="2-1-HTTP协议用于客户端和服务器端之间的通行"><a href="#2-1-HTTP协议用于客户端和服务器端之间的通行" class="headerlink" title="2.1 HTTP协议用于客户端和服务器端之间的通行"></a>2.1 HTTP协议用于客户端和服务器端之间的通行</h2><p>有时候，按实际情况，两台计算机作为客户端和服务器端的角色有可能互换。但就仅从一条通信线路来说，服务器端和客户端的角色是确定的，而用HTTP协议能够明确区分哪端是客户端，哪端是服务器端。</p>
<h2 id="2-2-通过请求和响应的交换达成协议"><a href="#2-2-通过请求和响应的交换达成协议" class="headerlink" title="2.2 通过请求和响应的交换达成协议"></a>2.2 通过请求和响应的交换达成协议</h2><p>HTTP协议规定，请求从客户端发出，最后服务器端响应应该请求并返回。换句话说，肯定是先从客户端开始建立通行的，服务器端在没有接收到请求之前不会发送响应。</p>
<p>下面则是客户端发送某个HTTP服务器的请求报文中内容</p>
<pre><code class="http"><span class="keyword">GET</span> <span class="string">/index.htm</span> HTTP/1.1
<span class="attribute">Host:hackr.jp</span>
</code></pre>
<p>起始行开头的GET表示请求访问服务器的类型，称为方法。随后的字符串/index.htm指明了请求访问得的资源对象，也叫做请求URI。最后的HTTP/1.1，即HTTP的版本号，用于提示客户端使用的HTTP协议功能。</p>
<p>综合来看，这段请求内容的意思是：请求访问某台HTTP服务器上的/index.htm页面的资源。</p>
<blockquote>
<p>请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。</p>
<p>响应报文基本上由协议版、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段和内容实体构成的</p>
</blockquote>
<h2 id="2-3-HTTP是不保存状态的协议"><a href="#2-3-HTTP是不保存状态的协议" class="headerlink" title="2.3 HTTP是不保存状态的协议"></a>2.3 HTTP是不保存状态的协议</h2><p>HTTP是一种不保存状态，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求和响应都不做持久化处理。</p>
<p>使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事物，确保·协议的可伸缩性，而特意把http协议设计成如此简单。</p>
<p>HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。</p>
<h2 id="2-4-请求URI定位资源"><a href="#2-4-请求URI定位资源" class="headerlink" title="2.4 请求URI定位资源"></a>2.4 请求URI定位资源</h2><p>HTTP协议使用URI定位互联网的资源。正是因为URI的特点功能，在互联网上任意位置的资源都能发访问到。</p>
<h2 id="2-5-告知服务器意图的HTTP方法"><a href="#2-5-告知服务器意图的HTTP方法" class="headerlink" title="2.5 告知服务器意图的HTTP方法"></a>2.5 告知服务器意图的HTTP方法</h2><p>GET：获取资源</p>
<p>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。</p>
<p>例子：</p>
<pre><code class="http">GET/index.html HTTP/1.1
Host:www.hackr.jp
/返回index.html的页面资源
</code></pre>
<p>POST：传输实体主体</p>
<p>POST方法用来传输实体的主体</p>
<p>虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST功能与GET功能很相似，但POST的主要目的并不是获取响应的主体内容。</p>
<p>例子</p>
<pre><code class="http">POST/submit.cgi HTTP/1.1
HOST:www.hackr.jp
Content-Length:1500(1500字节的数据)
/返回submit。cgi接收数据的处理结果
</code></pre>
<p>PUT：传输文件</p>
<p>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存在请求URI指定的位置。</p>
<p>例子</p>
<pre><code class="http">PUT/example.html HTTP/1.1
HOST:www.hackr.jp
COntent-Typr:text/html
Content-Length:1560
/响应返回状态吗204 No Content（比如html已经存在服务器上了）
</code></pre>
<p>HEAD：获取报文首部</p>
<p>HEAD方法与GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等</p>
<p>DELETE：删除文件</p>
<p>DELETE方法用来删除文件，是与PUT方法相反的方法。DELETE方法按请求URI删除指定的资源。</p>
<p>OPTIONS：询问支持的方法</p>
<p>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。</p>
<p>例子</p>
<pre><code class="http">OPTIONS * HTTP/1.1
Host:www.hackr.jp
/响应：
HTTP/1.1 200 OK
Allow:GET,POST,HEAD,OPTIONS
(返回服务器支持的方法)
</code></pre>
<p>TRACE：追踪路径</p>
<p>TRACE方法是让Web服务器端将之前的请求通行返回给客户端的方法。</p>
<p>CONNECT：要求用隧道协议连接代理</p>
<p>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。</p>
<h2 id="2-6-使用方法下达命令"><a href="#2-6-使用方法下达命令" class="headerlink" title="2.6 使用方法下达命令"></a>2.6 使用方法下达命令</h2><p>向请求URI指定的资源发送请求报文时，采用称为方法的命令。</p>
<h2 id="2-7-持久连接节省通信量"><a href="#2-7-持久连接节省通信量" class="headerlink" title="2.7 持久连接节省通信量"></a>2.7 持久连接节省通信量</h2><h3 id="2-7-1-持久连接"><a href="#2-7-1-持久连接" class="headerlink" title="2.7.1 持久连接"></a>2.7.1 持久连接</h3><p>为了解决TCP每次断开连接的问题，HTTP/1.1和一部分HTTP/1.0想出了持久连接的方法。持久连接的特点，只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p>
<blockquote>
<p>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早的结束，这样web页面的显示速度也就提高了。</p>
</blockquote>
<p>在HTTP/1.1中，所有的连接默认都是持久连接。</p>
<h3 id="2-7-2-管线化"><a href="#2-7-2-管线化" class="headerlink" title="2.7.2 管线化"></a>2.7.2 管线化</h3><p>持久连接使得多数请求以管线化方式发送称为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p>
<p>这样就能够做到<strong>同时并行发送多个请求，而不需要一个接一个地等待响应了</strong></p>
<h2 id="2-8-使用Cookie的状态管理"><a href="#2-8-使用Cookie的状态管理" class="headerlink" title="2.8 使用Cookie的状态管理"></a>2.8 使用Cookie的状态管理</h2><p>无状态协议的优点：由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。</p>
<p><strong>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端状态</strong></p>
